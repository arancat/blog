<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-js-basics-11-function" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/11/js-basics-11-function/" class="article-date">
  <time datetime="2020-03-11T02:42:36.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/11/js-basics-11-function/">js-basics-11-function</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>function<br>重点：事件处理程序的运行环境，如何解除事件处理程序，事件处理模型（冒泡，捕获），阻止默认事件，事件对象，事件委托，事件分类</p>
<p>1、ele.onxxx = function (event) {}<br>程序 this 指向是 dom 元素本身（指向自己）</p>
<p>、obj.addEventListener(type, fn, false);<br>程序 this 指向是 dom 元素本身（指向自己）</p>
<p>解除事件处理程序<br>1、ele.onclick = false/‘’/null;    ==&gt;    解除 ele.onxxx = function (event) {}<br>2、ele.removeEventListener(type, fn, false);==&gt;解除 addEventListener(type, fn, false) 3、ele.detachEvent(‘on’ + type, fn);    ==&gt; obj.attachEvent(‘on’ + type, fn);<br>注:若绑定匿名函数，则无法解除<br>例用 div.onclick = null;解除事件，</p>
<p>3、obj.attachEvent(‘on’ + type, fn);<br>程序 this 指向window<br>例让 obj.attachEvent 指向自己，function handle(){}里面是事件处理程序</p>
<p>例只能执行一次的事件的写法</p>
<p>4、封装兼容性的 addEvent(elem, type, handle);方法（必须会）<br>addEvent 是给一个 dom 对象添加一个该事件类型的处理函数例</p>
<p>例 ele.removeEventListener(type, fn, false);    1、事件冒泡：</p>
<p>结构上存在父子关系的元素，如果点击到子元素，会一级级向父元素传递这个事件<br>（从代码的角度是自底向上一层层冒泡的）<br>例加了 margin，只点黄色的，还是出现了 box,content,wrapper。所以与视觉无关</p>
<p>test 如果填 function(){}别人就找不到他，就没办法清除，所以此时的函数体要写在外面<br>例 ele.detachEvent(‘on’ + type, fn);清除绑定时一摸一样的 obj.attachEvent(‘on’ + type,<br>fn);</p>
<p>事件处理模型 — 事件冒泡、捕获事件处理的两个模型：事件冒泡、捕获（不能同时存在） 例</p>
<p>2、事件捕获：（只有谷歌有，最新火狐有）</p>
<p>2）IE 没有捕获事件<br> 一个对象的一个事件类型，只能存在一个事件处理模型（冒泡或捕获）<br>obj.addEventListener(type, fn, true);第三个参数为true 就是事件捕获<br>例点击黄的：先红的捕获事件并且执行，再绿的捕获事件并且执行，最后只执行事件黄的。捕获是把结构的最外面先抓住。最外面先捕获，再一层层向里面捕获，最里面的是按常规执行。<br>例把 false 改成 true，就变成了事件捕获<br>html 部分沿用左侧冒泡情况的代码，只把 false 改成 true 就变成事件捕获了</p>
<p>只点了黄色区域，但是出现了 box,content,wrapper，往下漏了，就是事件冒泡</p>
<p>思考：同一个对象的同一个事件类型，上面绑定了两个事件处理函数，一个符合冒泡，一个符合捕获，点击一个元素后，是先捕获，还是先冒泡？<br>3、触发顺序，先捕获，后冒泡</p>
<p>取消冒泡和阻止默认事件<br>例不给 div 绑定事件处理函数，依然会冒泡（document 冒泡到 div 上）</p>
<p>例 html 部分沿用上一页冒泡情况的代码</p>
<p>例给 div 也帮个事件（点红色，也冒泡到 document）</p>
<p>在每一个事件处理函数中【div.onclick=function(){}】，我们可以写一个形参（如 e），系统可以传递事件对象（记载了数据发生时的状态和信息）到这个参数里面去</p>
<p>例    改变了冒泡和捕获的顺序</p>
<p>1）W3C 标准 event.stopPropagation();但不支持 ie9 以下版本<br>例事件对象上有一个 event.stopPropagation();取消冒泡事件</p>
<p>2）IE 独有 event.cancelBubble = true;【实际上谷歌也实现了】<br>例 ie 里面事件对象上有一个 event.cancelBubble = true;能取消冒泡事件</p>
<p>这个的顺序是先捕获红色，再捕获绿色，boxBubble 黄色区域事件执行，box 黄色区域事件执行，冒泡到绿色，冒泡到红色（谁先绑定，谁先执行，boxBubble 先绑定， 所以先执行）<br>4、focus，blur，change，submit，reset，select 等事件不冒泡</p>
<p>3）封装取消冒泡的函数 stopBubble(event)</p>
<p>3）event.preventDefault(); W3C 标注，IE9 以下不兼容<br>例</p>
<p>4）event.returnValue = false; 兼容 IE<br>例</p>
<p>5）封装阻止默认事件的函数 cancelHandler(event);<br>例</p>
<p>例浏览器点右键出菜单，是一个事件（默认事件）</p>
<p>例 a 标签有一个跳转的默认时间，如何取消看下面</p>
<p>2）return false;    兼容性非常好，以对象属性的方式注册的事件才生效（这是句柄的方式阻止默认事件，只有句柄的方式绑定事件才好使）<br>例</p>
<p>ele.onxxx = function (event) {}是句柄的绑定方式，才能用 return false;</p>
<p>2、事件源对象:（找事件源对象的方法） event.target    火狐独有的event.srcElement    Ie 独有的<br>这俩 chrome 都有<br>例事件源对象的兼容性写法</p>
<p>事件委托<br>例我们给每个 li 绑定事件，要求点哪个 li 就输出哪个内容，这不涉及闭包问题</p>
<p>上面的写法不好（如果是三千亿个 li 就没效率），不能动态，要用事件源和事件冒泡</p>
<p>事件委托：利用事件冒泡，和事件源对象进行处理优点：<br>1.性能  不需要循环所有的元素一个个绑定事件<br>2.灵活  当有新的子元素时不需要重新绑定事件<br>例给每个 li 绑定事件，再增加 li 也能使用</p>
<p>扫雷的雷也可以放 ul 上<br>作业：预习下面的三个词，写拖拽功能（鼠标按住方块跟着动，松开就不跟着走）<br>答案</p>
<p>上面这个写法有问题，鼠标在方块的左上角，不在你点击他时候的位置</p>
<p>思路：上面是把点击鼠标的点设置成方块的 left 和 top（就是把鼠标的点设置成了左顶点，这样就少了个距离），我们把这个距离算上就可以了，加上鼠标第一次点击时候的离方块上边和左边的距离再赋给左上角了<br>之前是把 div.onmousemove 写在div 上面，有一个 bug，我们按住鼠标迅速离开方块，方块就不会跟着动，一直按住鼠标，再一进去，又可以带着方块动了，是一个事件监听的问题（鼠标挪动频次大于事件监听频次），我们写成 document.onmousemove就可以了</p>
<p>上面这个写的很粗糙，没有封装也没有绑定。document.onmousemove=function(){}这种写法是不可以的，要用 addEventListener 绑定。作业就是把上面绑定成函数，函数名叫 function drag (elem) {}<br>例</p>
<p>面试问题，什么是事件捕获，一个是冒泡，一个是捕获 obj.addEventListener(type, fn, true);他所说的第二种捕获不是事件处理模型，而是一种真实的事件获取的过程，用于解决拖拽鼠标出方块的问题<br>仅在 ie 好使，利用 div.setCapture();会捕获页面上发生的所有事情，都获取到自己身上。对应的用 div.releaseCapture();释放。但是方法比较老旧，一般不用。</p>
<p>例 click 不能监听右中</p>
<p>4、如何解决 mousedown 和 click 的冲突</p>
<p>click、mousedown、mousemove、mouseup、contextmenu、mouseover、mouseout、mouseenter 、 mouseleave<br>例 click=mousedown+mousemove</p>
<p>这三个事件的触发顺序是mousedown，mouseup，click<br>例 contextmenu 右键取消菜单，mousemove 是鼠标移动的事件<br>例相对应 mouseover、mouseout 鼠标覆盖区域与 mouseenter 、mouseleave 鼠标离开但是 mouseenter 、mouseleave 是 html5 的，都是鼠标进去，出来发生的变化</p>
<p>2、用button 来区分鼠标的按键，0/1/2<br>只有 mouseup、mousedown 两个能区分鼠标垫左右键<br>button 返回值，右键是 0，左键是 2，中间是 1<br>例</p>
<p>事件练习作业<br>1、拖拽应用：实现拖拽正常拖，但是点击就正常跳转<br>思路：拖拽由 down+move+up，但是不管隔多久都算一个 click，可以理解成拖拽不等于点击 click。看时间差解决：按下+抬起的时间差&gt;多少，就能知道是拖拽了。答案：按下之后才绑定move 事件，抬起了 move 事件就解除</p>
<p>2、应用 mousedown mousemove mouseup 3、随机移动的方块（完全随机）<br>思路：当把鼠标挪到方块里面去onmouseover 的时候，方块随机向八个方向挪动<br>4、mouseover<br>移动端 onmousedown 不能用，只能用 touchstart,touchmove,touchend</p>
<p>1、keydown，keyup，keypress</p>
<p>事件分类</p>
<p>例 change 对比鼠标聚焦，或失去焦点的时，两个状态是否发生改变，如果两个状态没有改变就不触发，如果发生改变就触发</p>
<p>2、触发顺序是 keydown &gt; keypress &gt; keyup</p>
<p>keydown 可以响应任意键盘按键，keypress 只可以相应字符类键盘按键<br>检测字符类不准确，keypress 检测字符很准。但是 keydown 能监控所有，包括上下左右都能监控，但是 keypress 只能监视字符。<br>用法：如果你想监控字符类按键，并想区分大小写，就用 keypress，如果是操作类按键的话，就用 keydown（which：39 是给按键牌号 39，不是 asc 码）<br>2）keypress 返回ASCII 码，可以转换成相应字符<br>例连续按键盘按键的时候就是连续触发 keydown 和keypress，松开触发keyup</p>
<p>注意：游戏触发设置在 keydown 上，机械键盘抬起速度快反馈力量大，对游戏没用<br>小写的 a 的 charCode 返回的是<br>例利用下面，把 Unicode 编码转成对应值</p>
<p>二、文本操作事件<br>input，change，focus，blur</p>
<p>例 focus，blur 聚焦和失去焦点</p>
<p>三、窗体操作类(window 上的事件)    scroll，load<br>例 scroll 当滚动条一滚动，scroll 事件就触发了</p>
<p>ie6 没 fixed 定位，就用 position 的 top=原来的 top+滚动条的位置来写。absolute 定位相对于文档定位，用absolute 定位模拟 fixed 定位，挪动距离加载absolute 的 top 上读到 js 的时候就阻断页面，所以必须把 js 写在下面才能把上面的东西读出来。<br>例 load 重要但是不用。window.onload 发生在什么时候</p>
<p>利用了 onload 就能操作写在下面的 div 了，但是我们不能这样用。<br>理由：html 和 css 是一起解析的，在解析的时候会有 html 有 domTree，css 有 cssTree 生成（树形图的顶底是document，然后是html，然后是 head，body），两个树拼在一起是 renderTree。</p>
<p>什么时候把节点放在树里？dom 节点解析，如确定是 img 标签就把他放到树里。（先解析完 img，同时开启一个线程异步的去下载里面的内容，后下载完）。<br>我们把 js 的 script 标签写在最下面的好处是，这些刚刚解析完 js 就能操作页面了， 就更快了。而 window.onload 要等整个页面解析完，下载完才能操作 js，才能触发事件（效率很差）。onload 能提醒我们什么时候整个页面解析完毕。在设计广告时，就要用 onload，等整个页面下载完了才开始用，但是onload 绝对用于主程序里面。</p>
<p>小练习:fixed 定位 js 兼容版    //ie6 没有 fixed 定位，用 position:absolution 是相对于文档定位。模拟fixed 定位，跟着解决文档拖的问题。position-top= 原来的position-top</p>
<ul>
<li>滚动条的位置</li>
</ul>
<p>作业<br>1、完善轮播图，加按钮    //提示：用留的接口，加两个按钮，改参数<br>2、提(qie)取密码框的密码    //提示：监听键盘事件<br>3、输入框功能完善<br>4、菜单栏（二阶菜单栏）    //提示：先写一个 div，开始的时候 display：none，等鼠标挪上去，变成 display：block</p>
<p>5、贪食蛇游戏    //提示：蛇头动，蛇尾怎么跟着动，控制蛇头操作就可以了，蛇尾的每一节跟着前一节动<br>6、扫雷游戏    //注意闭包，有个扩散算法。<br>二维数组就是数组里面套数组(像矩阵)，可以表示坐标点<br>arr[1][1]说的是第二行第二列，也就是 22</p>
<p>可以尝试做：球击方块（板子）的游戏</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/11/js-basics-11-function/" data-id="ck7mq1njg0000e0u1bgmz24ly" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-10-dom" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/11/js-basics-10-dom/" class="article-date">
  <time datetime="2020-03-11T02:36:04.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/11/js-basics-10-dom/">js-basics-10-dom</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>DOM</p>
<p>重点：dom操作，节点替换，节点封装</p>
<p>在 es3 里面重复的参数是不报错的，但是在 es5 里面是会报错的<br>h<br>表示和修改文档所需的方法（对象、这些对象的行为和属性以及这些对象之间的关系。）DOM 对象即为宿主对象，由浏览器厂商定义，用来操作html 和 xml 功能的一类对象的集合。<br>也有人称DOM 是对 HTML 以及 XML 的标准编程接口。<br>xml    ==&gt;    xhtml    ==&gt;    html<br>xml 是最早的版本，xml 里面的标签是可以自定义的，被 js 里面的Jason 取代了<br>dom 不能改变 css 样式表,可以间接改变行间样式的 css</p>
<p>例：说的改变不了 css 是指改变不了css 的样式表，但是可以通过间接方式改变html<br>的行间样式来改变</p>
<p>1、找到 html 的方法：如 document.getElementsByTagName(‘div’)就能把所有的 div<br>都选出来。<br>如果想拿到第一个 div，写成 document.getElementsByTagName(‘div’) 后面就要加一个[0];就可以实现了<br>2、div.style 选出来代表行间样式，选出来的就是 dom 对象<br>3、js 不能写-，只能用小驼峰方法写。如background-color 写成 backgroundColor<br>例<br>有 dom 操作以后就变成动态交互可以操作的了（你动一下，他给你一个反应）<br>div.onclick 是加一个交互效果的事件监听</p>
<p>例实现点击一下改变一下</p>
<p>例写个选项卡，点第一个按钮出现第一对应的信息，点第二个按钮，第一个消失， 出现第二个的信息</p>
<p>下面的 button 就是个按钮</p>
<p>例写个小方块应用<br>document.body.appendChild(div);意思是在 body 里面放个 div<br>setInterval(function () {},100);是一个定时器功能，意思是每隔 100 毫秒就执行一次</p>
<p>把上面 setInterval(function){}改成以下样式：</p>
<p>最好用下面这种立即执行函数的写法：</p>
<p>把最上面 setInterval(function){}改成以下样式，可以让定时器停止</p>
<p>例 点了加速的按钮以后，移动的速度变快</p>
<p>例：现在要实现按住加速，不好写没写，看 js 运动课</p>
<p>按住加速：就是这一次按下与下一次按下的速度间隔时间十分短暂，就认为他加速了。<br>上面思路：每一次按下的时候都记录一个新的时间片段，都减去上一个执行的时间片段，如果时间片段都小于一定的毫秒数的话，我们让一个计数器去++，当连续小于的时候，就让计数器连续++,如果++到一定数的时候，我们认为是连续按了，再按就加速了，让每一次按的时候都判断一下,如果时间间隔过大的话，就让计数器重新归 0。——在 js 运动课里面讲</p>
<p>例 box-sizing:border-box;启动了另外一种盒模型</p>
<p>中间有<li img-date=”0”></li>*400，onmouseover 是鼠标滑过变成</p>
<p>把左边的案例，如图去掉边线</p>
<p>emmet 插件提供的方法：（打字操作）例 div*3<br>例 div.demo 就是直接设置了 class 名字例 div.demo#only<br>例 div.demo#only</p>
<p>例 div.demo#only &gt; p[style=’background-color:red;width:100px;height:100px;’]</p>
<p>例 div&gt;(p^span.demo)<br>例加内容就用{}花括号<br>div&gt;(p^span.demo{123})</p>
<p>例 ul&gt;li{$}<em>10 这里面的$代表变量    ============&gt;<br>例 ul&gt;li{$</em>2}*10    ============================&gt;<br>可以看看 emmet 插件教程<br>在安装插件之前要按一个package control，在百度里面找，复制代码后，按 ctrl+~再把复制的代码粘贴到这里，按回车就可以了<br>在sublime text 里面preferences 里面找到package control，在搜索框找到install package<br>后打 emmet，Jsprettify（整理排序用的）<br>编辑器还有 vscode，webstrom，atom</p>
<p>DOM 基本操作(大部分都是类数组)——方法类操作1.对节点的增删改查    ()括号里面都不用写.或#<br> 查<br> 查看元素节点<br>document 代表整个文档（如果给 html 标签上面再套一层标签就是 document） document.getElementById() //元素 id 在 Ie8 以下的浏览器，不区分 id 大小写，而且也返回匹配 name 属性的元素，通过 id 标识我们来选择这个元素，一一对应<br>例</p>
<p>除了 id 以外，其余选择出来的都是一组，很少用 id 选择器<br>.getElementsByTagName()    //标签名，这是一个类数组，最主流的用法，经常用<br>例把页面里面所有的 div 都选择出来</p>
<p>从 dom 开始，我们所学的一切系统给我们生成的成组的东西，基本上都是类数组例加个[0]就选中了第一个div，如果不加 0，那个 div 表示的是一个数组，设置背景颜色就会报错</p>
<p>例把下面所有的div 都拿出来</p>
<p>只拿出第二个 div，加上[1] ，或者在控制台上打 div[1]<br>例选择第一个 p 的方式如下</p>
<p>例只拿出 demo 的 p 标签写法如下：</p>
<p>注意哪怕整个文档只有一个demo，也要加[0]，不然选出来的就是一个组</p>
<p>getElementsByName(); //IE 不支持需注意，只有部分标签 name 可生效（表单，表单元素，img，iframe），不是在所有的浏览器都能用——开发一般不用<br>例</p>
<p>.getElementsByClassName()    // 类名 -&gt;缺点： ie8 和ie8 以下的 ie 版本中没有，可以多个 class 一起，不是所有浏览器都能用<br>.querySelector()    // css 选择器，只能选一个，在 ie7 和 ie7 以下的版本中没有<br>.querySelectorAll()    // css 选择器，全选，选一组，在 ie7 和 ie7 以下的版本中没有<br>.querySelectorAll()和.querySelector()选出来的元素不是实时的（是静态的），所以一般不用，其他的再怎么修改，跟原来的没有关系<br>id 选择器不能太依赖，一般当顶级框架存在，在 css 中一般用 class 选择器<br>query 是一个词条</p>
<p>例.querySelector()和.querySelectorAll()选出来的元素不是实时的，是静态的，是副本</p>
<p>DOM 基本操作——非方法类的操作<br> 遍历节点树：(灵活，兼容好)——关系类的选择<br>parentNode  → 父 节点    (最顶端的 parentNode 为#document);<br>childNodes → 子节点们（直接的节点数）节点包括文本节点，属性节点<br>firstChild → 第一个子节点lastChild → 最后一个子节点nextSibling →后一个兄弟节点previousSibling → 前一个兄弟节点</p>
<p>例 parentNode → 父节点</p>
<p>下面的都是实时的</p>
<p>childNodes → 子节点们</p>
<p>例.querySelectorAll()选中了所有的 div，但是实时操作不能实时反馈</p>
<p>节点为什么是 7？<br>答案第一个节点是<div>后面的文本节点（空格回车），第二个节点是元素节点<br><strong><span>1</span></strong>，第三个节点是跟着的文本节点（空格回车），第四个节点是<span></span>，第五个是跟着的文本节点（空格回车），第六个是<em></em>，第七个是跟着的文本节点（空格回车）</p>
<p>后面的数字是调用 nodeType 返回的数字<br>元素节点    ——    1<br>属性节点    ——    2    （基本没用，）<br>文本节点    ——    3<br>注释节点    ——    8<br>document    ——    9<br>DocumentFragment    ——    11</p>
<p>答案七个，第一个节点是<div>后面的文本节点（空格回车），第二个节点是注释节点，第三个节点是跟着的文本节点（空格回车），第四个节点是元素节点<br><strong></strong>，第五个是跟着的文本节点（空格回车），第六个是<span></span>， 第七个是跟着的文本节点（空格回车）</p>
<p>答案七个，123 和空格等是一个文本</p>
<p>例 nextSibling →后一个兄弟节点 ，previousSibling → 前一个兄弟节点</p>
<p> 基于元素节点树的遍历（不含文本节点）<br>（除 children 外，其余 ie9 及以下不兼容）<br>parentElement -&gt; 返回当前元素的父元素节点 (IE 不兼容) 例</p>
<p>例 children -&gt; 只返回当前元素的元素子节点</p>
<p>例 nextElementSibling / previousElementSibling -&gt;返回后一个/前一个兄弟元素节点<br>（IE 不兼容)</p>
<p>例 node.childElementCount    === node.children.length 当前元素节点的子元素节点个数(IE 不兼容)——基本不用，因为与 length 相等<br>例 firstElementChild -&gt; 返回的是第一个元素节点(IE 不兼容) lastElementChild -&gt; 返回的是最后一个元素节点(IE 不兼容)</p>
<p>除 children 外，parentElement、node.childElementCount、firstElementChild、<br>lastElementChild、nextElementSibling、 previousElementSibling 在 ie9 及以下不兼容<br>真正常用的就是children，兼容性好</p>
<p>1、nodeName</p>
<p>每一个节点的四个属性</p>
<p>数字是调用 nodeType 返回的数字元素节点    —— 1</p>
<p>元素的标签名，以大写形式表示,只读，不能写<br>例 nodeName</p>
<p>属性节点    —— 2    （基本没用，class=“demo”就是一个属性节点）<br>文本节点    —— 3<br>注释节点    —— 8<br>document    —— 9<br>DocumentFragment    ——    11<br>例把 div 下面所有的直接子元素节点挑出来，放在数组里面返回，不能用 children</p>
<p>2、nodeValue<br>Text 文本节点或 Comment 注释节点的文本内容,可读写</p>
<p>3、nodeType（最有用）<br>该节点的类型，只读返回这个 div 的所有的元素节点</p>
<p>4、attributes<br>Element 节点的属性集合<br>例</p>
<p>例当且仅当这种情况下是false（没空格，没回车）</p>
<p>例属性的节点是div 上面的，不是 div 里的</p>
<p>DOM 接口<br>dom 结构树代表的是一系列继承关系</p>
<p>属性名不能改，属性值可以改，但是我们一般不用这种方法我们一般用 getAttribute 和setAttribute 去取<br> 节点的一个方法 Node.hasChildNodes();——他有没有子节点，返回值是 true 或 false</p>
<p>document 继承自 HTMLDocument.prototype。HTMLDocument.prototype 继承自 Document.prototype</p>
<p>DOM 基本操作<br>1.getElementById 方法定义在 Document.prototype 上，即Element 节点上不能使用。2.getElementsByName 方法定义在 HTMLDocument.prototype 上，即非 html 中的document 以外不能使用(xml document,Element)<br>3.getElementsByTagName 方法定义在 Document.prototype 和 Element.prototype 上例选 div 里的 span</p>
<p>开发中，经常利用先选择的父级，在他父级里面再次选什么元素来定位一个元素例</p>
<p>4.HTMLDocument.prototype 定义了一些常用的属性，body,head,分别指代 HTML 文档中的<body><head>标签。</p>
<p>5.Document.prototype 上定义了 documentElement 属性，指代文档的根元素，在 HTML<br>文档中，他总是指代<html>元素</p>
<p>6.getElementsByClassName、querySelectorAll、querySelector 在Document,Element 类中均有定义<br>作业 1.遍历元素节点树，要求不能用 children 属性（在原型链上编程）<br>答案：低级方法，给一个父节点，把子节点全部遍历出来，并打印<br>高级方法：打印树形结构 → 分层打印出来<br>先看 div 再看子元素节点， 再挨个判断</p>
<p>2.封装函数，返回元素 e 的第 n 层祖先元素</p>
<p>3.封装函数，返回元素 e 的第 n 个兄弟节点，n 为正，返回后面的兄弟节点，n 为负， 返回前面的，n 为 0，返回自己。<br>答案</p>
<p>上面在 ie9 以下不能用。考虑到兼容性，可以按照下面思路写</p>
<p>1 是元素节点的返回值，用for 循环和三目运算：</p>
<p>如果 for（）{}循环的执行体是空的，那么可以不写{}</p>
<p>4.编辑函数，封装 children 功能，解决以前部分浏览器的兼容性问题<br>答案</p>
<p>1、增</p>
<p>DOM 基本操作</p>
<p>document.createElement();    //增加或创建元素节点（标签）——常见<br>例在括号里面写什么字符串，就创建什么标签</p>
<p>左上加了 123，但是页面里面没有显示，用右上方法即可document.body.appendChild(div) document.createTextNode(); //创建文本节点<br>document.createComment();   //创建注释节点<br>document.createDocumentFragment();    //创建文档碎片节点，最后讲</p>
<p>5.自己封装hasChildren()方法，不可用children 属性<br>答案</p>
<p>2、插——剪切操作PARENTNODE.appendChild();    可以理解成.push</p>
<p>例选择我们把邓宝宝插入到 span 里面去</p>
<p>例在 div 后，span 前插入 strong</p>
<p>例在 div 后，span 前插入 strong 的基础上，把 i 放 strong 前面</p>
<p>3、删</p>
<p>例把 span 放div 里面</p>
<p>4、替换<br>parent.replaceChild(new, origin);    //用新的 new 去置换旧的origin</p>
<p>PARENTNODE.insertBefore(a, b);一定是 div 先 insert a，before b<br>例</p>
<p>strong 插入效果见右侧</p>
<p>1、Element 节点的一些属性</p>
<p>DOM 基本操作</p>
<p>例下面的 innerText 让 span 没有了，所以赋值要谨慎</p>
<p>innerHTML   ==&gt;    可取，可写，可赋值<br>innerText    ==&gt;    可取，可赋值 (老版本火狐不兼容) / textContent(火狐使用这个， 老版本 IE 不好使)<br>例 div.innerHTML 可以改变 div 里面的 HTML 的内容</p>
<p>2、Element 节点的一些方法ele.setAttribute()    //设置ele.getAttribute();    //取这个值行间属性可以设置系统没有的例</p>
<p>div.innerHTML = “123”;是覆盖</p>
<p>用.setAttribute()设置属性</p>
<p>用.getAttribute()取这个值</p>
<p>例通过 div.setAttribute(‘id’,’only’)动态的去改 div 的值</p>
<p>可赋值，可写值的才能+=<br>下面是用 innerHTML 改变css 行间样式</p>
<p>当满足一定条件时，if 就可以动态操作了，配合事件连成整体操作<br>这个行间属性可以设置系统没有的。data-log 是打点，点击率，这是人工设置的行间属性，不是系统定义的</p>
<p>例 innerText 可取可赋值<br>赋值会覆盖掉（能覆盖标签）</p>
<p>例如何取这个 data-log？</p>
<p>例给三个标签，让他们行间有一个属性 this-name，比如第一个 DIV，第二个SPAN</p>
<p>low 方法 div.innerHTML,剩下全手写</p>
<p>如果想改变一个div 结构或 dom 结构或 html 结构的 class，直接用 div.className=””就可以了，不用setAttribute<br>作业<br>1.封装函数 insertAfter()；功能类似 insertBefore(); insertAfter 是系统没有提供的<br>提示:可忽略老版本浏览器，直接在Element.prototype 上编程</p>
<p>2.将目标节点内部的节点顺序，逆序。（标签逆序） eg:<div> <a></a> <em></em></div></p>
<div><em></em><a></a></div>
利用 appendChild 和剪切，第一次先操作倒数第二个，第二次操作倒数第三个，写个
for 循环
3.封装 remove(); 使得 child.remove()直接可以销毁自身

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/11/js-basics-10-dom/" data-id="ck7mps94m0000jgu1hrzcfpb3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-9-es5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-9-es5/" class="article-date">
  <time datetime="2020-03-10T15:53:33.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-9-es5/">js-basics-9-es5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>es5.0 严格模式</p>
<p>（这章就是讲 es3.0 和 es5.0 产生冲突的部分） 浏览器是基于 es3.0 和 es5.0 的新增方法使用的。如果两种发生了冲突，就用 es3.0。<br>es5.0 严格模式是指 es3.0 和 es5.0 产生冲突发部分就是用 es5.0，否则就用es3.0。es5.0 严格模式的启动“use strict” ;<br>用法在写“use strict”，可以写在全局的最顶端，也可以写在某函数（局部）的最顶端，推荐使用局部的。</p>
<p>在 es5.0 不能用 argument.callee，但是 es3.0 可以用例 function test( ){ }里面加“use strict” ;是局部启动严格模式<br>全局严格模式<br>局部函数内严格模式（推荐）<br>就是一行字符串，不会对不兼容严格模式的浏览器产生影响。<br>不支持with，arguments.callee，function.caller，变量赋值前必须声明，局部 this<br>必须被赋值(Person.call(null/undefined) 赋值什么就是什么),拒绝重复属性和参数<br>例<br>浏览器升级到 es5.0 才好用写 strict( );就有风险<br>写成“use strict” ;有一个向后兼容的作用<br>例 es5.0 严格模式不让使用 with。with 可以改变作用域链<br>with（）括号里面的代码会按照正常顺序执行，但是如果在括号里面添加了对象，就会把对象当做 with 要执行的代码体的作用域链的最顶端（最直接的最近的 AO）。</p>
<p>下面这个 with 看到的就是 var obj 的 name （with 改变作用域链）</p>
<p>例命名空间应该像下面这样用的，with 可以简化代码<br>这也是 with 的运用方式<br>用 with 表示 document.write<br>with 过于强大，可以改作用域链，失去效率，所以 es5.0 不能用<br>rguments.callee 在 es5.0 严格模式下报错</p>
<p>es5.0 严格模式中：变量赋值前必须声明，局部 this 必须被赋值(Person.call(null/undefined) 赋值什么就是什么),拒绝重复属性和参数（this 不在指向window）</p>
<p>例局部 this 必须被赋值(Person.call(null/undefined) 赋值什么就是什么)</p>
<p>该对象的 constructor 是 Test，</p>
<p>全局的 this 指向 window</p>
<p>例拒绝重复属性和参数（this 不在指向window）</p>
<p>eval 很强大，能把字符串当成代码来执行<br>但是约定俗成在es3.0 中都不能使用 eval。eval 是魔鬼，因为会改变作用域</p>
<p>如果改变 global，他改变的是全局的<br>当情况不同，eval 改变的作用域是不同的<br>eval 还有自己独立的作用域<br>理解：可以把回调函数理解为先定义好了函数，执行的时候再回头调用<br>dom 这章之前是笔试面试的重点</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-9-es5/" data-id="ck7m2wj1f0000hgu15epbcjaq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-8-try-catch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-8-try-catch/" class="article-date">
  <time datetime="2020-03-10T15:49:28.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-8-try-catch/">js-basics-8-try-catch</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> try…catch</p>
<p>防止我们报错</p>
<p>try 花括号{里面会正常执行，但是遇到 b 报错时 b 就执行不出来，后面的代码 c 就不<br> 执行了，但是外面的代码d 还能执行}catch(e)，这个 e 可以随便写，写 abc 都可以， 也是个形参</p>
<p>在 try 里面的发生错误，不会执行错误后的 try 里面的代码<br>catch</p>
<p> 如果 try 里面的代码不出错，在catch 里面的代码就不执行；<br> 如果 try 里面的代码出错，catch 负责补抓到错误信息封装到里面（error.massage     error.name），错误对象只有message 和 name。</p>
<p>try{}catch(e) {}finally{}</p>
<p>例在 es5.0 不能用 argument.callee，但是 es3.0 可以用</p>
<p>例 function test( ){ }里面加“use strict” ;是局部启动严格模式</p>
<p>Error.name 的六种值对应的信息：<br>（前面是错误名称，后面是错误信息）<br>1.EvalError：eval()的使用与定义不一致<br>//eval 是不被允许使用的<br>2.RangeError：数值越界<br>3.ReferenceError：非法或不能识别的引用数值<br>//未经声明就使用，没有定义就使用<br>4.SyntaxError：发生语法解析错误<br>// Syntax 是语法解析（）<br>5.TypeError：操作数类型错误<br>6.URIError：URI 处理函数使用不当<br>//引用地址错误<br>大部分都是 3 和 4 这种错误<br>伪代码也可以写了，可以写 var  老邓 = 123；这就是伪代码<br>var str = avs    ==&gt;    ReferenceError</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-8-try-catch/" data-id="ck7m2m6400000you166y8bkxa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-7-array" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-7-array/" class="article-date">
  <time datetime="2020-03-10T15:40:36.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-7-array/">js-basics-7-array</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数组</p>
<p>重点：数组常用方法，系统内部负数兼容问题，类数组，数组去重问题</p>
<p>一、数组的定义(来源于Array.prototype)<br>1）new Array(length/content);    var arr = new Array(1,2,3,4,5 ); 2）字面量    var arr = [1,2,3,4,5];<br>二、数组的读和写<br>arr [ num ]        //不可以溢出读，结果 undefined arr[num] = XXX;    //不可以溢出读<br>arr[num] = xxx;    //可以溢出写<br>es3.0 最标准最基础    es5.0    es6.0，最新的 es7.0 还没有普及，今天讲的都是 es3.0<br>对象的定义方式 1 字面量.2 构造函数,3 自定义构造函数 4object.create<br>数组是一种特殊的对象，在本质上两者没有太大的区别<br>例可以写 var arr = [,]    //稀松数组，相当于定了两个位置，conlogo 结果是undefined</p>
<p> 封装 type 方法<br>定义对象方式：自变量，构造函数，自定义的构造函数，Object.create<br>定义数组的方式：var arr = [ ] ;数组自变量；var arr = new Array ( ) ;系统提供。两者区别就只一位数的情况<br>数组能用的方法来源于Array.prototype<br>例 var arr = [ ] ;<br>如果写 var arr = [ 1, ,1]，出来就是 1，undefined*1，1<br>数组不是每一位都有值，稀疏数组例 var arr = new Array ( ) ;<br>var arr = new Array(1,2,3,4,5);跟上面效果一样</p>
<p>例 var arr = [ ];和 var arr = new Array( );唯一的区别是在 var arr = new Array( );只传了一个参数的情况下，会被当成长度，并且成为一个稀松数组</p>
<p>如传进去的参数是一个小数，就非法例</p>
<p>数组常用的方法一、改变原数组（在原来数组基础上去改变） 1）reverse,sort,push,pop, unshift, shift,<br>2）splice</p>
<p>例 unshift 是从第一位加东西</p>
<p>forEach filter map reduce reduceRight slice concat,join—&gt;split,toString<br>在控制台操作<br>例 push 是在数组的最后一位添加数据，可以添加一个，也可以添加很多个</p>
<p>例说明能重写</p>
<p>例数组有三位，想在数组最后一位添加东西<br>var arr = [ 1, 2, 3 ];如果在第四位加东西写成arr = [3]。    //length-1 位添加东西<br>例</p>
<p>Array . prototype.push = function ( ){    //不能写形参<br>例 pop 是剪切方法（把最后一位数剪切出去）。在 pop( )括号里面不能传参，写了会忽略</p>
<p>例数组不能从-1 位插入东西</p>
<p>可以用两个数组拼接成一个数组的方式添加东西例 reverse 逆反</p>
<p>例 splice 一种剪切，切片<br>// 这是从第零位到第五位<br>/arr.splice(从第几位开始，截取多少长度，传参在切口处添加新的数据)<br>arr.splice(1,2);    //从第 1 位开始截取 2 位，传参可以不填<br>截取的是[1,2]</p>
<p>例 arr.splice(1,1,0,0,0);<br>//意思是从第 1 位起截取 1 位，然后加上 0,0,0 这三个数<br>例 var arr = [1,2,3,5];    //1 是第 0 位，2 是第一位，3 是第二位，5 是第三位<br>arr.splice(3,0,4);<br>变成 arr    ==&gt;    1,2,3,4,5<br>例 var arr = [ 1,2,3,4 ];<br>arr.splice(-1,1);<br>//这里的-1 是倒数第一位<br>数组一般的方法都可以带负数</p>
<p>例下面是系统内部解决负数的问题的兼容</p>
<p>思维方式：上面就控制了升序<br>这个函数第一次调动时，会把数组的第一位和第二位传进来，也就是a=1，b=3，然后通过规则比较，当你把返回值返回为正，为负，为 0。<br>传参的顺序（但是这个顺序是位子的顺序，不是按数字比），第一次是 1,3，第二次 1,5,第三次 1,4,第四次 1,10，第五次 3,5,第六次 3,4,第七次 3,10，第八次 5,4，第九次<br>5,10，第十次 4,10；依次传参（符合冒号排序的算法） 是以换位置的方式改变顺序<br>例 var arr = [ 2,13,19,4];<br>//到 13 这一位时，换位置变成了[ 2,4,19,13]<br>例下面这种方式变成了降序</p>
<p>例 sort 给数组排序（按照从小到大），改变原数组</p>
<p>在 sort 后面加 reverse 就是降序例下面这个是按 asc 码排序的</p>
<p>所以给我们留了个接口，如下图<br>sort<br>1 必须写两形参 2 看返回值 return<br>1）当返回值为负数时，那么前面的数放在前面，<br>2）当返回值为正数时，那么后面的数在前，<br>3）为 0，不动<br>右边的<br>return 1;    //此处的 1 代表返回正的<br>return -1;    //此处的-1 代表返回负的</p>
<p>记住升序 return a –  b ;    降 序 return b – a ;<br>直接调用 arr.sort( )比的是 asc 码，要在里面填函数才可以</p>
<p>例给一个有序的数组，乱序。当我们没规律可以遵循的时候，返回的是随机的</p>
<p>// Math.random() 会生成一个 0 到 1（包括 0，但是不包括 1）的随机数<br>例给他们三个按照年龄升序</p>
<p>可以把右上改成简化版</p>
<p>例按字符串长度排序</p>
<p>例按字节长度排序</p>
<p>下面略微修改一下    </p>
<p>例 concat 连接， 把后面的数组拼到前面，并成立一个新的数组，不影响之前的两个数组。不能改变原数组</p>
<p>例 toString 是把数组当做字符串展示出来</p>
<p>例 slice 从该位开始截取，截取到该位，并不改变原数组，这里也可以写负数</p>
<p>把下面字符串拼到一起下，字符串是在栈内存里面的，先进后出</p>
<p>用下面这种方式更好，join 里面不传参默认用逗号连接，传空串</p>
<p>slice 并不改变原数组 slice 完了以后需要有东西接收，不然没有意义</p>
<p>1、可以利用属性名模拟数组的特性2、可以动态的增长length 属性</p>
<p>类数组</p>
<p>slice 里面可以填 0 个参数，也可以填 1 个参数，也可以填两个参数<br>1、如果填两个参数，slice（从该位开始截取，截取到该位） 如 arr.slice(1,2)从第一位开始截取，截取到第二位<br>2、如果填一个参数，从第几位开始截取，一直截取到最后。如果 arr.slice(1) ，从第 1 位开始截取，截取到最后一位<br>3、不写参数就是整个截取数组（把类数组转换成数组的时候经常使用到）<br>例  join 括号里面需要用字符串形式（标准语法规定），就会用加的东西连接起数组</p>
<p>例 join 可逆的东西：split( )是 string 字符串方法</p>
<p>split 按照什么拆分为数组。用什么拆，什么就没了，按-拆就去掉-，按 4 拆就去掉 4。<br>split 可以返回数组，数组可以返回字符串</p>
<p>3、如果强行让类数组调用push 方法，则会根据 length 属性值的位置进行属性的扩充。<br>例这个看着像数组，但是数组有的方法，他全部都没有，所以他是类数组</p>
<p>类数组长得像数组，但是没有数组所拥有的的方法。例</p>
<p>例下面是类数组的基本形态</p>
<p>关键点在 length 上面，根据 length 改变而改变，走一下length，即： Array.prototype.push = function (target){<br>this[obj.length] = target; this.length ++;<br>}</p>
<p>在控制台 push(‘d’)以后，obj 的object 多了一个 3：d，长度也变成了 4<br> 类数组    。<br>例：如果给一个对象加上 splice 方法，那么这个对象就长得像数组了。但他仍然<br> 象，但是可以当做数组来用，需要自己添方法。（如下图）</p>
<p>如果对象 obj 调用这个方法，那么this 变成了obj</p>
<p>答案：“1”：“a”，“2”：“c”，“3”：“b”，“length”：4</p>
<p>作业 1、封装 type 方法</p>
<p>作业答案：<br>1、封装 type（这个方法是一个工具类方法，可以存在库里面），区分 typeof 方法<br>1）先分类，原始值，引用值<br>2）区分引用值，先判断是不是 null<br>数组，对象，包装类(new number )会返回object，通过 Object.prototype.toString</p>
<p>简化写法–进一步简化</p>
<p>2、数组去重（利用对象的特性做数组去重，去重就是去掉重复）<br>思路：写一个对象，把数组的每一位当做对象的属性名。利用对象的特性（同一属性名不可以出现两次），先把第一位当做属性名添加进去，属性值随便写个，再看第二位，如果第二位在对象里面有属性名，就看下一位，如果对象里面没有属性名， 就把这个值添加进去当属性名。只看对象的属性名，就去重了，这个方法叫hash。</p>
<p>每一圈循环都要this.length; 写成 var len = this.length;这样直接放值能少一些运算。[this[i]]代表数组的第几位。“abc”可以随便填值（要求是字符串，但是不为 false），但是填[this[i]]= [this[i]];在数组有 0 的时候就会有 bug。<br>if 里面取到值什么都不敢，取到 undefined 才开始操作，所以写非！，没有值，才处理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-7-array/" data-id="ck7m2e4pp00000wu1d3idflwp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-6-this" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-6-this/" class="article-date">
  <time datetime="2020-03-10T15:33:04.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-6-this/">js-basics-6-this</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>this<br>重点：this预编译过程，arguments,克隆(深层克隆，浅层克隆)，</p>
<p>this —&gt; 指 向 window</p>
<p>可以改变函数运行时this 指向<br>func()里面的 this 指向 obj<br>谁调用这个方法,这个方法里的 this 就是指向谁    →</p>
<p>例<br>a.say 是 function 函数体<br>function (fun){<br>//this → b<br>//console.log(this)→b<br>fun( );</p>
<p>}<br>fun()空执行，走预编译<br>在 b.say(a.say)中<br>a.say 当做参数传进来了</p>
<p>答案 fun( )是 222    a.say 是 111    b.say(a.say);是 222    b.say( );是 333</p>
<p>arguments arguments.callee 指向函数的引用（函数自己） function.caller</p>
<p>例我们要初始化数据，是 100 以内的阶乘，用立即执行函数找到自己的引用来解决</p>
<p>在哪个函数里面的 arguments.callee 就指代了哪个函数</p>
<p>例 caller 谁叫他，caller 不能用在 arguments 里面</p>
<p>demo 被调用的环境是 test 所以这个 caller 指代的 test 例</p>
<p>答案是 456<br>把上面这题变形：</p>
<p>答案打印 234，要 console.log(foo);是全局的 foo，但是这里 this.foo 的 this 是指向全局 window 的，相当于就把外面的 123 改成了 234<br>例</p>
<p>答案 123，new 了以后，隐式 var this = Object.create(print.prototype)这时候 this.foo 不<br>再指向 window，转而指向var this，所以打印的时候找不到 234，就到全局找到 123</p>
<p>答案运行 test( )是 0，5，0【之前其中 this.a 指代的是 window，所以是 5】运行 new test( )是 0，undefined ，0【因为 this 上没有 a，所以打印 undefined<br>在执行 test( )之前，AO 被定义{a:undefined}，执行之后，AO 被执行{a:0,this:window} 在执行new test( )时会隐式的var this = Object.create(test.prototype)简化就是var this ={<br>    proto : test prototype}一个对象上面没有的属性，打印出来就是 undefined new test( );执行的时候 AO 是{a:0，this:{} }</p>
<p>答案 undefined，2，报错 hello is no defined<br>因为 hello 没有被定义，所以报错例</p>
<p>答案打印 One！ 例</p>
<p>答案：test1，test2，marty，做不了有 bind，test3<br>例</p>
<p>bar.a=’a’;<br>把{a:”002”}<br>变成<br>{a:’a’}<br>答案 a，b 其中 print( ) ( )第一个括号返回的是一个函数，第二个再来函数执行</p>
<p>思考上一个题做深度克隆，分析他是什么，建立是什么，收尾需要一个递归，提示：</p>
<p>作业：做一个深度克隆（copy 后，各自独立，互不影响）<br>思路：需要一个分析环节，分析是什么，是原始值就按原来的方法拷贝过来，是引用值就分析是数组还是对象。如果是数组，就新建一个数组；如果是对象，就新建一个对象。再一层层看，里面有一个递归。引用值不能直接拷贝，引用值拷贝的是地址</p>
<p>var obj = {<br>name : “abc”, age : 123,<br>card : [‘visa’, ‘master’], //原始对象<br>wife : {<br>name : “bcd”, son : {<br>name : “aaa”<br>}</p>
<p>deepClone ( origin [ prop ], target [ prop ]);<br>}else{    //else 后面是原始值<br>target [ prop ] = origin [ prop ];<br>}<br>}<br>}<br>return target;<br>}</p>
<p>}<br>var obj1 = {<br>name : “abc”, age : 123,<br>card : [ obj.card[ 0 ],obj.card[ 1 ] ],<br>//要拷贝的对象，进行 obj 里面的数组，对这个数组的拷贝再一次拷贝<br>wife : {<br>name : “bcd”, son : {<br>name : “aaa”<br>}<br>}<br>}<br>function deepClone(origin, target){<br>var target = target | | {},    //有就用你的，没有就用后面的<br>toStr = Object.prototype.toString,    //引用，目的是简化<br>arrStr =  “ [ Object Array ]  ”;    //引用，目的是简化比对<br>for ( var prop in origin ) {    //从原始 origin 拷贝到 target<br>if( origin . hasOwnProperty( prop ) ){    //先判断是不是原型上的属性，如果是false 就是原型上的<br>if( typeof (origin [ prop ] ) !== “null” &amp;&amp; typeof ( origin [ prop ] ) ==<br>‘object’) {<br>if ( toStr.call( origin    [ prop ] ) ) == arrStr ){ target [ prop ] = [ ];<br>}else{<br>target [ prop ] = { };<br>}</p>
<p>深度克隆的步骤<br>1、先把所有的值都遍历一遍（看是引用值和原始值）<br>用 for ( var prop in obj )，对象和数组都可以使用<br>2、判断是原始值，还是引用值？用 typeof 判断是不是object 1）如果是原始值就直接拷贝<br>2）如果是引用值，判断是数组还是对象<br>3、判断是数组还是对象？（方法instanceof【看a 的原型链上有没有b 的原型】、toString、constructor，建议用 toString,另外两个有个小bug——跨父子域不行） 1）如果是数组，就新建一个空数组；<br>2）如果是对象，就新建一个空对象。<br>4、建立了数组以后，如果是挨个看原始对象里面是什么，都是原始值就可以直接考过来了；或者，建立了对象以后，挨个判断对象里面的每一个值，看是原始值还是引用值<br>5、递归<br> 三目运算符    ?    :<br> 形式：?问号前面是一个条件判断，判断 true 就走：冒号前面的；false 就走：冒号后<br> 面的，并且会返回值    条件判断？    是 ： 否    并且会返回值三目运算符是简化版的 if（条件判断）{是在这里}else{否在这里}<br>例 var num = 1 &gt; 0 ? 2 + 2 : 1 + 1;<br>//答返回值为 4<br>例 var num = 1 &lt; 0 ? 2 + 2 : 1 + 1;<br>//答返回值为 2<br>例 ar num = 1 &gt; 0 ? ( “10” &gt; 9 ? 1 : 0 ) : 2;<br>//答 1<br>例 var num = 1 &gt; 0 ? ( “10” &gt; “ 9 “ ? 1 : 0 ) : 2;<br>//答 0，因为“10” &gt; “ 9 “ 比的是ASCII 码，一位位比，一零小于 9，先用 1 和<br>9 比，在 asc 妈里面 1 小于 9；<br>当“10” &gt;    9 字符串和数字比，会先转换成数字再比较</p>
<p>例可利用三目运算符简化克隆的代码<br>for ( var prop in origin ) {<br>if( origin . hasOwnProperty( prop ) ){<br>if( typeof (origin [ prop ] ) !== “null” &amp;&amp; typeof ( origin [ prop ] ) ==<br>‘object’) {<br>target [ prop ] = toStr.call (origin [ prop ] ) ==arrStr ? [] : {}; deepClone ( origin [ prop ], target [ prop ]);<br>}else{    //else 后面是原始值<br>target [ prop ] = origin [ prop ];</p>
<p>例 var arr = new Array ( 10 );长度为 10 的稀疏数组，括号里面只有一位数，就代表着长度，并且里面每一位都没有值，console 里面会是undefined*10。并且里面不能写小数，会报错。<br>var arr1 = [ 10 ]；<br>数组的读和写，基本上没有报错的情况，除非是引用了没有的方法<br>js 数组是基于对象的，数组是一种特殊的对象</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-6-this/" data-id="ck7m264vb0000egu169s5eyli" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-5-inherit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-5-inherit/" class="article-date">
  <time datetime="2020-03-10T15:26:38.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-5-inherit/">js-basics-5-inherit</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>继承</p>
<p>重点：call/apply方法，共享原型，圣杯模式，命名空间优化，对象枚举 </p>
<p>作用，改变 this 指向。<br>区别，后面传的参数形式不同。<br>toFixed 是保留两位有效数字<br>例有个 bug，在控制台 0.14*100<br>出现 14.0000000000002，是 js 开发精度不准例向上取整 Math.ceil(123.234)<br>答案 124<br>例向下取整 Math.floor(123.999)<br>答案 123<br>例 Math.random()是产生一个 0 到 1 区间的开区间 随机数例</p>
<p>所以一般在这种情况下，我们不用 toFixed，因为精度不准确</p>
<p>例用这种方法取整更好，就不会精度不准确</p>
<p>例</p>
<p>注意：之前 js 在小数点后面最多能容纳 15-17 位，但是升级后能用科学计数法表示如 2e-17（是 2 乘以 10 的负 17 次方）<br>而小数点前面只能容纳 16 位的运算， 可正常计算的范围是小数点前后 16 位<br>例    任何一个方法都可以.call<br>.call 才是一个方法执行的真实面目</p>
<p>直接执行Person.call ( )和Person ( )没有区别Person.call( );括号里面可以传东西<br> 如果Person.call( obj );里面的 call 让 person 所有的 this 都变成 obj<br>不 new 的话，this 默认指向 window。call 的使用必须要new<br>call 的第一位参数用于改变this 指向，第二位实参（对应第一个形参）及以后的参数<br> 都当做正常的实参，传到形参里面去<br> 借用别人的方法，实现自己的功能。<br>例写 test（）和写 test.call（）是一样的，→<br>例<br>如右图<br>两个人的需求有重复部分</p>
<p>call 改变 this 指向，借用别人的函数，实现自己的功能。只能在你的需求完全涵盖别人的时候才能使用<br>如果不想要 age 这个，就不能使用这种方法</p>
<p>继承发展史<br>//问题：过多的继承了没用的属性</p>
<p>Person.call(this, name, age, sex);里面的 this 现在是 new 了以后的 var this={}<br>利用Person 方法，实现了Student 自己的封装例 function Wheel ( wheelSize,</p>
<p>不能继承借用构造函数的原型 每次构造函数都要多走一个函数</p>
<p>所以不算标准的继承模式<br>==&gt;浪费效率</p>
<p>this 放进去的前提，这个函数必须是 new 来的</p>
<p>apply 也是改变 this 指向的，只是传参列表不同，第一位也是改变 this 指向的人，第<br> 二位，apply 只能传一个实参，而且必须传数组 argunments call 需要把实参按照形参的个数传进去</p>
<p>4.圣杯模式<br>圣杯模式是在方法三的共有原型，但是在共有原型的基础上有改变。共享原型是：son.prototype=father.prototype</p>
<p>例：左下这种方法就不好使了，相当于右下。还是原型指向有问题，new 的时候用的是原来的原型，再 F.prototype =father.prototype 没用，son.prototype 没发生改变</p>
<p>例，在雅虎时代，封装了 YUI3 库来解决方法三的不足，与圣杯模式相似。现在不用<br>YUI3 库，现在用 jq</p>
<p>联系到闭包作用：可以实现封装，属性私有化。<br>例为什么在外部执行的divorce 能用内部的变量？能换成 xiaozhang？<br>因为 this.divorce 在对象上，由于对象被返回了，这个方法也被返回了。<br>因为闭包。这个函数被储存到了外部，所以储存了这个函数的执行期上下文。所以可以用这个闭包。所以var prepareWife 被下面的 this=fn 三个函数共用，这三个函数分别与 fn Deng 形成了闭包，共同用 Deng 的AO,所以可以在外部随意存取。</p>
<p>deng.prepareWife 是 undefined 的，表面上看起来不是自己的，但是实际上只有对象<br> 自己通过对象自己设置的方法可以去操作他。外部用户通过对象. prepareWife 是看不<br> 到的。只有自己能看到，就是闭包的私有化的运用。</p>
<p>上面的 var inherit 与右边 的 var inherit 是一样的意思建议写上面的这种</p>
<p>上面的 var F 这个 F 形成了闭包，成为了这个函数的私有化变量，而且变成私有化变量就更好</p>
<p>多人开发，对象命名容易重复，就要解决命名空间的问题<br>右边是命名空间老旧的解决方    ==&gt;<br>用的时候，用下面的写法</p>
<p>下面是现在公司最常见的方法：用闭包来解决（也可用 webpack），返回方法的调用。<br>init 是初始化，入口函数，入口名字。init 调用了这个函数的功能</p>
<p>obj.eat().smoke().drink().eat().sleep();</p>
<p>上面改成下面的写法：用 return this，就可以连续调用和执行了。deng.smoke().drink()</p>
<p>上面是用 return this 连续调用</p>
<p>obj.prop    查看就用.XXXX<br>例想要传序号几，就会调用几<br>老旧办法看右边，<br>然后 case1。。。 case2。。。连着往下写这种方法不好，下面的方法更好<br>var obj = { name : “abc” }<br>用方括号来访问属性也是一样的（里面必须是字符串）  这两种基本上完全相同 obj.name    →    obj [ ‘name’ ] 想实现属性名的拼接，只能用方括号的形式</p>
<p>for in 循环(简化版 for 循环)，目的是便利对象，通过对象属性的个数来控制循环圈数，这个对象有多少属性循环多少圈，而且在每一圈时，都把对象的属性名放到 Prop 里面 在枚举里面，一定要写成 obj[prop]不能加字符串<br>1.hasOwnProperty 2.in<br>3.instanceof<br>枚举也就是遍历：挨个知道信息的过程就叫这个数据组的遍历例</p>
<p>例</p>
<p>//上面就是 for in 循环，就是遍历用的。通过对象的属性个数来控制循环圈数，有多少个属性就会循环多少圈。<br>for（var prop in obj）在循环每一圈的时候，他会把对象的属性名放在 prop 里面。想遍历谁就 in 谁，prop 可以写别的，obj 就是我们想要遍历的对象。<br>var XX in XX 的格式是固定的。<br>var 也可以写在外面，写成var key； for（key in obj1）效果是一样的</p>
<p>写成下面这样会出错</p>
<p>上面 obj.prop 系统以后我们写的是 obj[‘prop’]，系统会以为我们是在让他访问 prop<br>这个属性，不会把prop 当成一个变量来使用。写成obj[prop]就可以成功访问了。</p>
<p>写对象时用方括号的形式不容易犯错例<br>右边写法会把原型上面的东西也拿出来</p>
<p>如果在遍历的时候，我们不想把原型上面的属性拿出来，可以用 hasOwnProperty，<br> 一般与 for in 循环成套出现<br>hasOwnProperty 是一个方法，来判断这个对象是你自己的还是原型的， 任何一个对象里面都有 hasOwnProperty，里面是需要传参的，把属性名传进去（如 prop）。下面达到了如果不是自己的属性，是原型上的属性，就不会返回。</p>
<p>注明：for in 循环理论上可以返回原型和原型链上的东西，一旦这个原型链延展到了的 object.prototype 上，不会打印系统的，只会打印自带的。<br>var obj = {<br>    proto     : {<br>lasrName：“deng“，<br>    proto     : Object . prototype    //不会打印这个object.prototype</p>
<p>in 操作符：很少用<br>in 操作符你的也是你的，你父亲的也是你的，只能判断这个对象能不能访问到这个属性，包括原型上；不是判断属性属不属于这个对象的</p>
<p>判断一个属性属不属于这个对象的只能用 hasOwnProperty<br>instanceof 操作用法类似于 in，但是完全不同<br>A instanceof B 的意思是 A 对象是不是 B 构造函数构造出来的；记住是：看A 对象的原型链上有没有B 的原型<br>解决了<br>例</p>
<p>判断这个变量是数组还是变量例</p>
<p>例区别传的变量是数组还是对象的方法：一是 constructor，二是 instanceof</p>
<p>例    加 Object . prototype.abc = ‘123’;    加个！变成只有不是他的才打印</p>
<p>第三种区分数组还是对象的方法：想让数组调用他的toString 方法<br>Object . prototype . toString . call ( [ ] ) ;    //[]会替换 this<br>Object . prototype . toString = function ( ) {<br>识别 this（谁调的他，这个this 就是谁） 返回相应的结果</p>
<p>}<br>obj . toString ( ) ;</p>
<p>例：下面这段 js 代码执行完毕后x，y，z 的值分别是多少？<br>var x = 1, y = z = 0; function add(n){<br>return n = n + 1;</p>
<p>进制<br>十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f<br>十六进制的中 10 是十进制的 16，    1f = 16 + 15<br>二进制中的 10 是十进制的 2，11 是十进制的 3</p>
<p>}<br>y = add(x); function add(n){<br>return n = n + 3;</p>
<p>}<br>z = add (x);<br>答案 1，4，4，同一个函数，后面会覆盖前面的，fn add 会提升到前面例：下面代码中 console.log 的结果是[1, 2, 3, 4, 5]的选项是：<br>A、function foo (x){<br>console.log(arguments) return x<br>}<br>foo(1, 2, 3, 4, 5)<br>B 、 function foo (x){ console.log(arguments)<br>return x<br>} (1, 2, 3, 4, 5)<br>C 、 ( function foo (x){ console.log(arguments)<br>return x<br>})(1, 2, 3, 4, 5)<br>D、function foo(){bar .apply (null, arguments);} function bar (x) {console.log(arguments);}<br>foo(1, 2, 3, 4, 5);<br>答案 A, C,D    其中b 执行不了,但是不报错<br>bar 里面传了一下参数。bar .apply (null, arguments);写成 bar (arguments);<br>例：一行文本，水平垂直居中<br>答案：height = line height    text-align:center<br>例：请问以下表达式的结果是什么？<br>parseInt(3, 8)        parseInt(3, 2)        parseInt(3, 0) A.3，3，3    B.3，3， NaN    C.3， NaN， NaN    D.other 答案 C 或D（有的浏览器 0 进制报错，有的不报错）</p>
<p>例：以下哪些是JavaScript 语言 typeof 可能返回的结果<br>A.string    B.array    C.object    D.null<br>例：JavaScript 的 call 和 apply 方法是做什么的，两者有什么区别？ 例：看看下面 alert 的结果是什么？<br>function b (x, y, a){ arguments [ 2 ] = 10; alert( a );<br>}<br>b(1, 2, 3);<br>如果函数体改成下面，结果又会是什么？<br>a = 10;<br>alert(arguments[2]);<br>答案两个都是 10<br>逗号操作符，这种情况，会看一眼 1，在看一眼 2，然后返回第二个，就是 2<br>例：</p>
<p>答案是 number</p>
<p>例    前面的 var this = Object.creat(test.prototype);是最标准的写法<br>new tes（t   ）；就会让 var this = Object.creat(test.prototype);如果不 new，this 指向 window</p>
<p>用括号把 function f （）{}转换成表达式，就被立即执行了，就找不到了。<br>因为 function f （）{}肯定是 true，所以会执行{}，但 typeof f 中的 f 已经找不到了<br>答案是 1undefined<br>下面是用友的题目<br>例：以下哪些表达式的结果为 true（    ）<br>A.undefined == null    B.undefined === null    C.isNaN(“100”)    D.parseInt(“la”) ==1<br>答案 A、C、D    //isNaN（”100”）意思是这个数经过 number 转换后是不是 NaN<br>C</p>
<p>parseInt（“1a”）==1。    引用值比的是地址</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-5-inherit/" data-id="ck7m1x4nz0000p4u1ambkaan5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-4-object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-4-object/" class="article-date">
  <time datetime="2020-03-10T15:19:48.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-4-object/">js-basics-4-object</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对象<br>（构造函数 包装类 原型  原型链）</p>
<p>1.用已学的知识点，描述一下你心目中的对象。<br>例</p>
<p>灰色的 undefined 是返回值，因为没有设置返回值，所以就是灰色的undefined</p>
<pre><code>.代表函数引用    </code></pre><p>改mrDeng.health 为this.health，此处this 指代的是自己，是第一人称，指的就是mrDeng。因为 this 是在一个方法里面，所以指的这个方法。<br>smoke : function (){ console.log(‘I am good’) this.health –;<br>},<br>2.属性的增、删、改、查<br>例在上面的基础上 mrDeng.wife = “xiaoliu”<br>也可以在控制台操作<br>3.<br>对象的创建方法<br>(2)构造函数<br>1)系统自带的构造函数 Object()<br>     new Object();Array();Number();Boolean();Date();<br>系统自带的构造函数Object()可以批量生成对象，每一个对象都一样，但是彼此相互独立。<br>在 Object()前面加个 new，变成 new Object()的执行，就会真正的返回一个对象，通过 return 返回，拿变量接受。var obj = new Object();<br>var obj = new Object();和 var obj = {};这样写区别不大</p>
<p>例 var obj = new Object();    例<br>obj.name = ‘abc’; obj.sex = “male”;<br>双引号和单引号都是表示的字符串，写双引号也可以写单引号，但是为了跟后端 php<br>配合最好写单引号。如果要打印一个单个的引号，用正则表达式转义字符\  注意等号和冒号的用法 obj.say = function(){}    var obj = { name : ‘abc’} 2）自定义<br>Object.create(原型)方法<br>例 function Person(){}</p>
<p>构造函数内部原理</p>
<p>Person 是可以随便写的，也是构造函数构造函数跟函数结构上没有任何区别 例 var person1 = new person();<br>必须用 new 这个操作符，才能构造出对象<br>构造函数必须要按照大驼峰式命名规则，但凡是构造函数就要大写，例如TheFirNa<br>例</p>
<p>car1 和 car 是长得一样，但是是不同的两个 car。方法名和对象名尽量不一样a 和A 变量是两个变量，var car = new Car 里面 car 和 Car 是两个变量<br>例<br>这里的 color 可以和上面的重复</p>
<p>通过参数，<br>使函数发生变化，变成自定义</p>
<p>前提必须要加 new，以下三步都是隐式的：<br>1.在函数体最前面隐式的加上var this = {}    空对象<br>2.执 行 this.xxx = xxx;<br>3.隐式的返回 return this<br>例</p>
<p>例 function Person(name, height){<br>//隐式的 var this = {}，下面正常执行 this<br>this.name = name; this.height = height; this.say = funtion (){<br>console.log(this.say);<br>//此处的 this 和外面的 this 不同<br>}<br>// 隐式的 return this;<br>}<br>console.log(new Person(‘xiaowang’, 180).name);<br>例也可以这样显式的写出来<br>function Person (name, height){<br>var that = {};    //显式写出来that.name = name;<br>that.height = height;<br>return that;    //显式写出来</p>
<p>例</p>
<p>答案现在的 peson 和 person1 都是 Object{}<br>如果 return 写成 return 123，会使 return 失效，如右上图<br>x 有 new 了以后就不能返回原始值，例如 123</p>
<p>var num =123;    →    原始值数字<br>只有原始值数字是原始值，原始值不能有属性和方法<br>属性和方法只有对象有，包括对象自己，数组，function</p>
<p>var num = new number 123;    →    构造函数。是对象 123，不是原始值数字</p>
<p>字符串类型的对象<br>var num = new Nunber(123);    //数字类型对象var str = new String(‘abcd’);        //字符串类型对象var bol = new Boolean(‘true’);    //布尔类型对象</p>
<p>undefined 和null 不可以有属性<br>不能写成 undefined.abc = 123;会报错</p>
<p>例原始值不可能有属性和方法，但经过了包装类(加隐式)可以调用一些属性与方法<br>var num = 4；<br>num.len = 3;<br>//系统隐式的加上 new Number(4).len = 3;  然后 delete<br>console.log(num.len);<br>//系统隐式的加上 new Number(4).len; 但是这个new number 和上面的 new number<br>不是同一个，所以返回undefined 而上面这些隐式的过程就是包装类例 var str = “abcd”;<br>str.length = 2;<br>//隐式的加上 new string(‘abcd’).length = 2;    delete<br>console.log(str); console.log(str.length);<br>答案是 abcd，4<br>例</p>
<p>str += 1;    //abc1<br>var test = typeof(str);    //test ==  “string”，返回  string，string 长度是 6<br>if(test.length == 6){<br>test.sign =  “typeof 的返回结果可能为 String”;    //这是原始值,原始值要赋属性值需要调用包装类，赋了跟没赋值是一样的，new String(test).sign=’xxx’;<br>}<br>conlogo.log(test.sign);    //new String(test).sign<br>答案 undefined<br>例</p>
<p>答案 A，里面并没有用参数<br>被写死了，传参不成功</p>
<p>例    答案：A<br>例：看看下面 alert 的结果是什么？<br>function b (x, y, a) { arguments[ 2 ] = 10; alert( a );</p>
<p>答案 1，2，1<br>例</p>
<p>}<br>b(1, 2, 3);<br>如果函数体改成下面，结果又会是什么？<br>a = 10；<br>alert(arguments[ 2 ]);<br>答案 10，10</p>
<p>例下面代码中 console.log 的结果是[1,2,3,4,5]</p>
<p>答 案 1，4, 4 同一个函数，后面会覆盖前面的fn add 会提升到前面</p>
<p>答案 ACD（枚举后面有清晰版）<br>例：请问以下表达式的结果是什么？<br>parseInt(3, 8)<br>parseInt(3, 2)<br>parseInt(3, 0)<br>答案选 3 或 4，值为 3，NaN，3（有的浏览器遇到 0 是报NaN） 例：以下哪些是JavaScript 语言 typeof 可能返回的结果：<br>A.string    B.array    C.object    D.null</p>
<p>原型<br>1.定义：原型是function 对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。 2.利用原型特点和概念，可以提取共有属性。<br>3.对象属性的增删和原型上属性增删改查。<br>4.对象如何查看原型 ==&gt;  隐式属性    proto    。 5.对象如何查看对象的构造函数 ==&gt; constructor。<br>例 person.prototype    //原型（描述一种继承关系），出生时就被定义好了<br>person.prototype ={}    //是祖先</p>
<p>将左上的共有的东西提取出来放在原型里面，如右上图</p>
<p>右上的 person 和 person1 都有一个共有的祖先Person.prototype</p>
<p>上面通过对象（后代）改原型（祖先）是不行的，在对象里面修改，只作用给自己改原型都不行，增加肯定也不行。对象可以删除属性</p>
<p>左上的简化写法见右上    // construnctor 是构造的意思（隐式是浅粉色）</p>
<p>浅粉色是系统帮你设置的，深紫色是自己设置的</p>
<p>自己身上有属性，原型上也有属性，取近的，用自己的</p>
<p>在原型内部自带constructor，指的是Car。通过 constructor 能找的谁构造的自己</p>
<p>例</p>
<p>例</p>
<p>constructor 可以被人工手动更改例</p>
<p>例</p>
<p>浅粉色的    proto    是系统的隐式的属性,前面两个_后面两个_，可以修改，尽量不改。在开发的时候，如果很私人可以写成_private，告诉同事别动。<br>上面的 proto 放的是原型。 proto 存的对象的原型<br>上面的 var this ={  proto   :person.prototype};这个对象并不是空的，这个 proto，当你访问这个对象的属性时，如果对象没有这个属性，那么就会访问 proto 索引，看看有没有。有一个连接的关系，原型和自己连接到一起<br>例</p>
<p>Person 的原型是可以被修改的</p>
<p>Person.prototype.name 这种.的写法是在原有的基础上把值改了。改的是属性，也就是房间里面的东西。<br>而Person.prototype={name:’cherry’}是把原型改了，换了新的对象。改了个房间。上面在 new 的时候 var this = {  proto :Person.prototype}里面的指向Person，此时Person.prototype 与 proto 指向的是一个空间，把他返回给var person。<br>先 new 再Person.prototype={name:’cherry’}已经晚了<br>在Person.prototype={name:’cherry’}时，Person.prototype 空间改了，但是 proto 指向的空间不变。<br>上面的步骤实际上是→<br>例</p>
<p>例</p>
<p>上面这种思考过程：程序执行顺序<br>1.先把 function Person(){}在预编译的过程中提到最上面2.再执行 Person.prototype.name =  ‘sunny’这一样行3.再执行 Person.prototype = {name:’cherry’}<br>4.最后执行 var    person = new Person();执行到 new 的时候，才会发生//var this<br>={ proto :Person.prototype}<br>5.下面的把上面的覆盖了6.答案是 cherry<br>例</p>
<p>这说明原型里面有原型例<br>原型链</p>
<p>执行 son.toString    //返回 function toString( ){ [native code] }，这里返回的是原型链终端的 toString<br>Grand.prototype.   proto     = Object.prototype    // Object.prototype 是原型链的终端</p>
<p> 原型链<br>1、如何构成原型链?（见上一个例子）<br>2、原型链上属性的增删改查<br>原型链上的增删改查和原型基本上是一致的。只有本人有的权限，子孙是没有的。<br>3、谁调用的方法内部this 就是谁-原型案例<br>4、绝大多数对象的最终都会继承自Object.prototype 5、Object.create(原型);<br>6、原型方法上的重写例</p>
<p>son.fortune.card2=’master’这种改，这是引用值自己的修改。属于 fortune.name 给自己修改，这是一种调用方法的修改<br>例</p>
<p>son.num++是 son.num=son.num+1 是先把父级的取过来再赋值+1， 所以爹的没变</p>
<p>例    例 var obj = { };也是有原型的<br>var obj = { };与 var obj1 = new Object( );效果是一样的写 var obj = { }; 系统会在内部来一个 new Object( );</p>
<p>obj1.   proto     </p>
<p>→    Object.ptototype;</p>
<p>但是在构造对象时，能用对象自变量 var obj = { };就不要用 var obj1 = new Object( );<br>例</p>
<p>console.log(this.name);    //如果写成 name 就会错，没有这个变量<br>例</p>
<p>//a.sayName ( )方法调用，就是 say.Name 里面的 this 指向，是谁调用的这个方法，this 就指向谁<br>例</p>
<p>this.height ++;    //这后面默认有一个 return undefined<br>例</p>
<p>对像自变量的原型就是Object.ptototype;<br>Object.create(原型);<br>//var obj = Object.create(原型);<br>Object.create 也能创建对象。var obj = Object.create（这里必须要有原型） 例</p>
<p>例</p>
<p> 绝大多数对象的最终都会继承自 Object.prototype<br>例 html 里面没有添加任何东西这样就报错</p>
<p>原型是隐式的内部属性，你加是没有用的</p>
<p>例    例<br>Object.create()在括号里面只能放null 或者Object，其余会报错<br>例 undefined 和null 没有原型，也就不可能有toString 方法</p>
<p>例下面 123.toString 首先会识别成浮点型，所以在后面直接加.toString 是不行的</p>
<p>数字想用 toString 方法，要经过包装类包装new Number(num)然后. toString<br>例加深上面的理解</p>
<p>而 new Number(num). toString 的原型是Nunber.prototype，而 Nunber.prototype 上面有一个.toString 方法，Nunber.prototype 也有原型Nunber.prototype. proto ，原型是<br>Object.prototype<br>假如 new Number 上面的prototype 上面有这个 toString，那么就不用 Object.prototype<br>的 toString。而这个 number 上面有这个 toString。<br>然后 number 上面的 toString 调用的是自己重写的 toString。<br> 原型上有这个方法，我自己又写了一个和原型上同一名字，但不同功能的方法，叫<br> 做重写（同一名字的函数，不同重写方式） 通过返回值，形参列表不同传参<br>同样的名实现不同功能的，就是重写</p>
<p>和原型链上终端方法名字一样，但实现不同的功能，叫做方法的重写。也就是覆盖</p>
<p>下面这个也是重写</p>
<p>例让 object 上面的 toString 重写了。<br>所以 num.toString()调用的是 number. prototype.toString。</p>
<p>如果调用的是 object. prototype.toString 结果会不一样。</p>
<p>例</p>
<p>例例例<br>document.write 会隐式的调用 toString 方法，其实打印的是 toString 的结果</p>
<p>没有原型就不能 toString<br>例</p>
<p>上面这个例子表示：我要打印的是 obj，实际上打印出来的是 toString 方法，也证明了 document.write 调用的是 toString 方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-4-object/" data-id="ck7m1l7qr0000o4u1gmrn2yvf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-3-closure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-3-closure/" class="article-date">
  <time datetime="2020-03-10T15:14:54.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-3-closure/">js-basics-3-closure</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>闭包（closure）</p>
<p>eg: Person();<br>四、模块化开发，防止污染全局变量<br>立即执行函数</p>
<p>例(function (){    //写成(function abc(){}())也调用不到<br>var a = 123; var b = 234;<br>console.log(a + b);<br>}())<br>例 (function (a, b, c){ console.log(a + b + c * 2);<br>}(1, 2, 3))这一行里面的(1,2,3)是实参例 var num = (function (a, b, c){<br>var d = a + b + c * 2 – 2; return d;<br>}(1, 2, 3))<br>答案 num = 7</p>
<p>}<br>答案这也是函数声明例 function (){<br>var a = 123;<br>}<br>test();<br>答案 test()；就是表达式，所以能执行<br>。    例 var test = function (){<br>console.log(‘a’);<br>}()<br>答案这是表达式，可以被执行，此时在控制台执行 test 的结果是 undefined，这个函数的名字就会被放弃<br>例+ function test(){<br>console.log(‘a’);<br>}()<br>答案加了个“正“，在趋势上要把他转换成数字，就是表达式了，既然是表达式就能被执行，就会放弃名字，此时console.log (test)，就会报错；这就是立即执行函数同样放了正号，负号，！就会放弃函数名字，转换成表达式；但是*和/不行，&amp;&amp;||前面放东西也行<br>例 var test = function (){}<br>其中= function (){}把 function 赋到 test 里面去叫表达式，var test 是声明<br>在执行时，会放弃这个函数，储存到 test 里面储存引用，让这个 test 恢复到被声明的<br>状态</p>
<p>例(function test(){console.log(‘a’);})()<br>这个被()包起来的 function 函数声明变表达式了，就能被外面的最后的()执行例(function test(){console.log(‘a’);} ())<br>最外面的大括号是数学运算符号，是最先被执行，其余的括号都是有语法意义的， 就把函数变表达式了<br>()也是数学执行符，能打印 a，但是执行 test 就报错，所以干脆就不写 test<br>例 function test (a, b, c, d){<br>console.log(a + b + c + d);<br>}(1, 2, 3, 4);    //写成(1)也是这种效果<br>理论上不能执行，只写()就会被当成执行符，但是(1, 2, 3, 4);这样写暂时不会当成运算符，没意义，但是不会执行，也不报错。还能调用 test<br>例先定义一个 10 位数的数组，就是在var arr = [function () {console.log(i);}有十个]并且把数组返回<br>function test (){    //定义个函数 test var arr = [];        //定义一个空数组<br>for (var i = 0; i &lt; 10; i ++){<br>//丰满空数组，让空数组添加十条数组， 每一条都是一个 function(){}<br>arr[i] = function () { //随着 for 循环 i 变， 数组 i 也变，arr 每一次都等于一个全新的函数体<br>document.write(i + “ ”);<br>}<br>}<br>return arr;    //把 arr 返回到外部<br>}<br>var myArr = test();<br>for (var j = 0; j &lt; 10; j ++){ //分别执行十个函数体，函数体里面定义了 document.write myArr<a href="">j</a>;<br>}<br>答案 10 10 10 10 10 10 10 10 10 10<br>第二个 for 是为了打印这个数组，麻烦写法myArr<a href="">0</a>; myArr<a href="">1</a>; 。。。myArr<a href="">9</a>; 过程 for (var i = 0; i &lt; 10; i ++){}执行了十次，产生了十个彼此独立的函数。并且把这十个函数放在数组里面去，还把数组返回了，这十个函数和 test 一起产生了一个闭包。<br>既然是闭包，那么访问 test 里面的变量时，实际上访问的是同一套，而 test 产生了<br>arr 和 i 变量（写在 for 循环里面的 i 变量），而这十个函数在外边要访问 i 变量，其实<br>访问的是同一个 i。</p>
<p>什么时候访问的？在test 执行完以后，在下面 for(j)访问的<br>第一个 i=0，转到 9 的时候，i ++变 10 终止 for 循环，结束的时候i=10，结束之后把return arr 返回，arr；<br>这十个函数都是为了打印 i 的，在外部访问 i 的时候i=10，所以打印的是 10<br>arr[i] = function () {<br>document.write( i + “ ”);<br>}<br>理解过程：在这个函数体中，当arr[0] 时，document.write(i)的 i 是不变的，还是 i， 等函数保存到外部之后，等执行的时候，才会去找i 的值。<br>这个赋值语句中，arr[0] =  函数;把一个函数体或者说是一个函数引用赋给数组的当前位，数组的当前位需要马上被索取出来的（数组现在是当前第几位，我们是知道的， 因为这个是执行语句），当 for(var i = 0)时，arr[i]会变成 arr[0]，但是这个 i 跟函数体里面的 d.w(i+“”）里面的 i 是没有关系的，因为函数体 function(){}不是现在执行，不会在意函数里面写的是什么，不是现在执行那么里面的 document.write 不会变成现实的值，不是现在执行就是函数引用（函数引用就是被折叠起来的，系统不知道里 面写的是什么）<br>在执行 myArr<a href="">j</a>;的时候，系统才会读 document.write(i +””)里面的语句在定义函数的时候是不看里面的，在执行的时候才看<br>例我们让上面这个变成打印 0,1,2,3,4,5,6,7,8,9，用立即执行函数解决<br>function test (){<br>var arr = [];<br>for (var i = 0; i &lt; 10; i ++){ (function (j) {<br>arr[j] = function () { document.write( j + “ ”);<br>}<br>}(i));<br>return arr;<br>}<br>var myArr = test();<br>for (var j = 0; j &lt; 10; j ++){ myArr<a href="">j</a>;<br>}<br>理解过程：相当于在 for 循环里面有十个立即执行函数 function(j){}<br>在第一圈 i 是 0，j 也是 0，function(){document.write( j + “ ”)}拿着 j=0，进行循环的第二圈 i 是 1，又有了一个新的j 是 1，反复循环<br>形成了十个立即执行函数，有十个 j 对应</p>
<p>例 for(var i = 0; i &lt; 10; i ++){ console.log(i);<br>}<br>答案 0,1,2,3,4,5,6,7,8,9<br>例 for(var i = 0; i &lt; 10; i ++){<br>(function(){<br>}())<br>}<br>中间 function 这个会执行 10 次</p>
<p>=“”等号后面的引号里面需要有值才可以    删除必须借助 delete mrDeng.sex</p>
<p>一定要注意——闭包的防范</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-3-closure/" data-id="ck7m1eexv0000uou1cdgsfsfv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-2-precompile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-2-precompile/" class="article-date">
  <time datetime="2020-03-10T15:09:38.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-2-precompile/">js-basics-2-precompile</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js 运行三部曲（主要探讨预编译）</p>
<p>1 语法分析 → 2 预编译 → 3 解释执行<br>预编译前奏<br>例 function test(){ console.log(‘a’);<br>}<br>test();<br>上面能执行例 test();<br>function test(){ console.log(‘a’);<br>}<br>也能执行，因为有预编译的存在例 var a = 123;<br>console.log(a);<br>答案 123<br>例 console.log(a);<br>var a = 123;</p>
<p>答案 undefined<br>例只写 console.log(a);就会报错<br>函数声明整体提升：函数不管写到哪里，都会被提到逻辑的最前面。所以不管在哪里调用，本质上都是在后面调用<br>变量    声明提升：把 var a 提升到最前面<br>var a = 123;这是变量声明再赋值。<br>变量    声明提升是把他拆分成var a; a = 123;然后把 var a 提升到最前面上面这两句话没办法解决下面例子的问题<br>例 function a(a){<br>var a = 234;<br>var a = function(){<br>} a();<br>}<br>var a =123;<br>1.imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象(就是window)所有。<br>全局对象是window<br>例 window.a = 10;<br>例 a = 10; ===&gt; windows.a = 10;<br>eg: var a = b = 123;<br>2.一切声明的全局变量，全是window 的属性。<br>例 var a = 123; ===&gt; window.a = 123;<br>window 就是全局的域<br>如果在全局变量在var a = 123；那么就会返回到 window<br>例 var a = 123<br>console.log(a) ===&gt; window.a<br>例 var a = b = 234;是把 234 的值赋给b，在把b 的值赋给 a<br>例 function test(){<br>var a = b = 123;<br>}<br>test()<br>写 test()代表执行 test，赋值是自右向左的，上面先把 123 赋给 b 的时候，b 未经声明，然后再声明 a，再 b 的值赋给 a，导致b 未经声明，所以b 归 window 所有<br>访问 window.a 是 undefined，访问 window.b 是 123<br>例 function test(){<br>var b = 123;</p>
<p>}<br>test(); console.log(window.b);<br>答案 undefined<br>window 就是全局例 var a = 123;<br>console.log(a);    → console.log(window.a);<br>例 var a = 123;<br>var b = 234; var c = 345; window{<br>a : 123,<br>b : 234,<br>c : 345<br>}<br>如果 var a 对应会有 window.a<br>预编译（解决执行顺序问题）<br>例 function fn(a){<br>console.log(a); var a = 123; console.log(a); function a (){} console.log(a);<br>var b = function (){} console.log(b); function d() {}<br>}<br>fn(1);<br>答案是 function a(){}//123//123//function    (){}<br>这个例子的形参是（a），变量声明也是 a<br>上面的例子按四部曲变化如下:<br>找形参和变量声明，将变量和形参（a）名作为AO 属性名，值为 undefined ，AO{<br>a : undefined, b : undefined,<br>}<br>（把实参值传到形参里）AO{ a : 1,</p>
<p>b : undefined,<br>}<br>function a () {}和 function d () {}都是函数声明，但是var b = function (){}不是。AO{ a : function a () {},<br>b : undefined,<br>d : function d () {}<br>}<br>执行第一行 console.log(a);时，用的是 AO{ a : function a () {},<br>b : undefined,<br>d : function d () {}<br>}<br>执行 var a =123;改变的是AO{ a : 123,<br>b : undefined,<br>d : function d () {}<br>}<br>在 b = function (){}时 AO{ a : 123,<br>b : function () {},<br>d : function d () {}<br>}<br>预编译发生在函数执行的前一刻<br>（函数）预编译的四部曲：<br>1.创建 AO 对象 Activation Object(执行期上下文，作用是理解的作用域，函数产生的执行空间库)<br>2.找形参和变量声明，将变量和形参名作为AO 属性名，值为undefined 相当于 AO{<br>     a : undefined, b : undefined<br>}<br>3.将实参值和形参统一（把实参值传到形参里）<br>4.在函数体里面找函数声明，值赋予函数体<br>（先看自己的AO，再看全局的 GO）<br>例子 function test (a, b){<br>console.log(a);<br>c = 0;</p>
<p>var c; a = 3;<br>b = 2;<br>console.log(b); function b (){};<br>function d (){}; console.log(b);<br>}<br>test(1);<br>答题过程：找形参和变量声明，将变量和形参名作为 AO 属性名，值为 undefined, AO{ a : 1,<br>b : undefined, c : undefined<br>}<br>函数声明 function b(){}和 function d(){}，AO{ a : 1,<br>b : function b(){}, c : undefined,<br>d : function d(){}<br>}<br>执行 console.log(a);答案是 1<br>执行 c = 0;变AO{<br>a : 1,<br>b : function b(){}, c : 0,<br>d : function d(){}<br>}<br>var c 不用管，因为 c 已经在 AO 里面了执行 a = 3;改AO{<br>a : 3,<br>b : function b(){}, c : 0,<br>d : function d(){}<br>}<br>执行 b = 2;改AO{ a : 3,<br>b : 2,</p>
<p>c : 0,<br>d : function d(){}<br>}<br>执行 console.log(b);答案是 2<br>function b () {}和 function d(){}已经提过了，不用管执行 console.log(b);答案是 2<br>例 function test(a , b){<br>console.log(a); console.log(b); var b = 234; console.log(b); a = 123;<br>console.log(a); function a (){} var a;<br>b = 234;<br>var b = function(){} console.log(a); console.log(b);<br>}<br>test(1);</p>
<p>答题过程： 将变量和形参名作为 AO 属性名，AO{ a : undefined,<br>b : undefined<br>}<br>将实参值和形参统一，AO{ a : 1,<br>b : undefined<br>}<br>找函数声明 function a (){}，AO{ a : function a (){},<br>b : undefined<br>}<br>执行 console.log(a);答案是 function a (){}<br>执行 console.log(b);答案是 undefined</p>
<p>执行 var b = 234;变 AO{ a : function a (){},<br>b : 234<br>}<br>执行 console.log(b);答案是 234<br>执行 a = 123;变AO{<br>a : 123,<br>b : 234<br>}<br>执行 console.log(a);答案是 123<br>然后 function a (){};var a ;都可以不看了执行 b = 234，b 值还是 234，不变<br>执行 var b = function (){}，变 AO{<br>a : 123,<br>b : function (){}<br>}<br>执行 console.log(a);答案是 123<br>执行 console.log(b);答案是 function (){}<br>下面开始讲全局的预编译<br>例 console.log(a);<br>var a = 123;<br>答案 undefined<br>例 console.log(a);<br>var a = 123; function a (){}<br>答案是打印 a 是 function a (){}<br>全局的预编译三部曲：<br>1、生成了一个 GO 的对象 Global Object（window 就是 GO）<br>2、找形参和变量声明，将变量和形参名作为GO 属性名，值为 undefined<br>3、在函数体里面找函数声明，值赋予函数体<br>例 console.log(a);<br>var a = 123; function a (){}<br>答案过程，GO{<br>a : undefined<br>}<br>函数声明GO{</p>
<p>a : function a (){}<br>}<br>执行 var a = 123;变 GO{ a : 123<br>}<br>执行 console.log(a);就是 123<br>GO === window， GO 和window 是一个东西<br>console.log(a);和 console.log(window.a);和 console.log(go.a);是一样<br>任何全局变量都是window 上的属性<br>没有声明就是赋值了，归window 所有，就是在 GO 里面预编译<br>例 function test(){<br>var a = b =123; console.log(window.b);<br>}<br>test();<br>答案 a 是 undefined，b 是 123<br>先生成 GO{<br>b : 123<br>}<br>再有AO{<br>a : undefined<br>}<br>先生成 GO 还是AO?<br>想执行全局，先生成 GO，在执行 test 的前一刻生成AO<br>在几层嵌套关系，近的优先，从近的到远的，有 AO 就看AO，AO 没有才看 GO<br>例 console.log(test);<br>function test(test){ console.log(test); var test = 234; console.log(test); function test(){<br>}<br>}<br>test(1);<br>var test = 123;<br>答题过程:想执行全局,先有 GO,GO{ test : undefined</p>
<p>}<br>发现有函数声明 GO{ test : function (){<br>…..<br>}<br>}<br>执 行 console.log(test)， 执行 test(1)之前生成 AO{<br>test : function (){}<br>}<br>执行 var test = 234;变成 234<br>AO 上面有就用 AO 的，没有就看 GO 的例 var global = 100;<br>function fn(){ console.log(global);</p>
<p>答 题 过 程 ，GO{ global : undefined<br>fn : undefined(没用可以不写)<br>}<br>变 GO{<br>global : 100 fn : undefined<br>}<br>执行 fn()之前，AO{ global : undefined<br>}<br>执行结果是 undefined，200<br>例</p>
<p>}<br>fn();<br>答题过程GO{<br>global : undefined, fn : function(){.    }</p>
<p>}<br>执行 var global = 100;变GO{ global : 100,<br>fn : function(){.    }<br>}<br>不看 function fn(){. }里面的东西<br>执行 fn()之前 AO{<br>访问 GO 的 global</p>
<p>答案//undefined    //undefined<br>过程GO{<br>a : undefined<br>test:undefined(没用可以不写)<br>}<br>AO{</p>
<p>//234    //234</p>
<p>}    b : undefined    //不管 if（a）{}，可以提出 var b 的 b<br>例    }<br>执行到 c=234，GO{<br>a : undefined c : 234<br>}<br>执行到 a=10，GO{ a : 10<br>c : 234}</p>
<p>例 function bar(){<br>return foo; foo = 10;<br>function foo(){} var foo = 11;<br>}<br>console.log(bar());<br>答案：function foo(){}<br>如果在第一行 return foo，下面有 foo 这个函数，一定打印这个函数例 console.log(bar());<br>function bar(){ foo = 10; function foo(){} var foo = 11; returm foo;<br>}<br>答案 11<br>例 console.log(b);<br>var b = function (){}<br>答案是 undefined<br>例现在在 if 里面定义函数声明 function 是不允许的，但是过去可以，下面就是过去的旧题，按可以来做</p>
<p>GO{<br>a : undefined<br>}<br>GO{<br>a : undefined<br>demo : function (){}<br>}<br>开始执行 a=100，GO{ a : 100<br>demo : function (){}<br>}<br>AO{<br>e : undefined, b : undefined, c : undefined, a : undefined<br>}<br>形参实参相统一，AO{ e : 1,<br>b : undefined, c : undefined, a : undefined<br>}<br>赋值AO{<br>e : function e (){}, b : undefined,<br>c : undefined,    旧规则里面可以提出 function(){}<br>a : undefined</p>
<p>}<br>执行 arguments[0] = 2;实参列表和传参是否相映射，变 AO{ e : 2,<br>b : undefined, c : undefined, a : undefined<br>}<br>执行 console.log(e);答案 2<br>if(a)由于 a 在 AO 里面是 undefined，所以不走 if</p>
<p>执行 a = 10;变AO{ e : 2,<br>b : undefined, c : undefined, a : 10<br>}<br>执行 console.log(b)，答案 undefined<br>执行 f = 123，变 GO{<br>a : 100,<br>demo : function (){}, f : 123<br>}<br>执行 console.log(c);    之前打印 function(){}，改语法后打印 undefined<br>执行 console.log(a);    答案 10<br>执行 console.log(a);    因为在外面是全局的，答案 100<br>执行 console.log(a);    答案 123<br>例</p>
<p>答题//1    false+1 因为有+，两边都不是字符串，就转换成数字，false 是 0<br>//false    false==1，false 肯定不等于 1，所以把 false 再赋给 demo<br>//undefined<br>typeof(a) 出 现”undefined”    -true 转换成数字是-1    +undefined 显示“NaN”<br>-1 + NaN = NaN<br>-1 + NaN + “” = “NaN”<br>“undefined” &amp;&amp; “NaN”转换成 boolean，就都是true<br>“11”* 2 是<em>把两边转换成了数字，所以 11 +“11”</em> 2 =33，33 == 33，两边相等<br>!!非非就是正<br>“ ”这不是空串，是空格字符串<br>!!” ”转换成 Boolean 为 true<br>!!””非非空串，转换为 Boolean 为 false</p>
<p>!!false 就是 false<br>true + false - false = 1 + 0 – 0 =1<br>11|| document.write(‘你觉得能打印？’)<br>||遇到真就听，1 为真，所以返回 1<br>例(window.foo || (window.foo = ‘bar’));求 window.foo<br>答案”bar”<br>这道题要先看(window.foo = ‘bar’)这一边的，再看左边的 window.foo，因为运算符的顺序；但是这道题错误的读法（从左到右）也是 bar<br>(window.foo || window.foo = ‘bar’);这么写就报错；||或运算符优先级高于=等号<br>作用域精解<br>[[scope]]:每个 javascript 函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供 javascript 引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域,其中存储了运行期上下文的集合。<br> 作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。<br> 运行期上下文:当函数在执行的前一刻，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁。<br> 查找变量：在哪个函数里面查找变量，就从哪个函数作用域链的顶端依次向下查找。函数类对象，我们能访问test.name<br>test.[[scope]]隐式属性——作用域例 function test (){<br>}<br>第一次执行 test();    →    AO{}    //AO 是用完就不要的第二次执行 test();    →    AO{}    //这是另外的 AO<br>例 function a (){<br>function b (){ var bb = 234; aa = 0;<br>}<br>var aa = 123; b();<br>console.log(aa)<br>}<br>var glob = 100; a();</p>
<p>0 是最顶端，1 是次顶端，查找顺序是从最顶端往下查<br>理解过程：bb 的AO 是拿到 aa 的 AO，就是同一个 AO，bb 只是引用了 aa 的 AO， GO 也都是同一个。function b(){}执行完，干掉的是b 自己的 AO（销毁执行期上下文）（去掉连接线），下次 function b 被执行时，产生的是新的b 的 AO。b 执行完只会销毁自己的 AO，不会销毁 a 的 AO。function a(){}执行完，会把 a 自己的 AO 销毁<br>【会把 function b 也销毁】，只剩 GO（回归到 a 被定义的时候），等下次 function a再次被执行时，会产生一个全新的 AO，里面有一个新的 b 函数。。。。。。周而复始例</p>
<p>理解过程<br>a 被定义 a.[[scope]]    →    0 : GO{}<br>a 被执行 a.[[scope]]    →    0 : aAO{}<br>1 : GO{}<br>b 被定义 b.[[scope]]    →    0 : aAO{}<br>1 : GO{}<br>b 被执行 b.[[scope]]    →    0 : bAO{}<br>1 : aAO{}<br>2 : GO{}<br>c 被定义 c.[[scope]]    →    0 : bAO{}<br>1 : aAO{}<br>2 : GO{}<br>c 被执行 c.[[scope]]    →    0 : cAO{}<br>1: bAO{}<br>2: aAO{}<br>3 : GO{}<br>当 c 执行完后，会干掉自己的 cAO，回到c 被定义的状态，当 c 再被执行时，会生成一个新的 newcAO{}，其余都一样，因为基础都是 c 的被定义状态<br>c 被执行 c.[[scope]]    →    0 : newcAO{}<br>1: bAO{}<br>2: aAO{}<br>3 : GO{}<br>如果 function a 不被执行，下面的 function b 和 function c 都是看不到的（也不会被执行，被折叠）。只有 function a 被执行，才能执行function a 里面的内容<br>a();不执行，根本看不到 function a (){}里面的内容</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-2-precompile/" data-id="ck7m1ab1600002gu10dycdq6o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2020/03/11/js-basics-11-function/">js-basics-11-function</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/11/js-basics-10-dom/">js-basics-10-dom</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/10/js-basics-9-es5/">js-basics-9-es5</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/10/js-basics-8-try-catch/">js-basics-8-try-catch</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/10/js-basics-7-array/">js-basics-7-array</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>
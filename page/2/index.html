<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-js-time" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/15/js-time/" class="article-date">
  <time datetime="2020-03-15T13:57:51.000Z" itemprop="datePublished">2020-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/15/js-time/">js-time</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js-time 总结更新完毕</p>
<img src="/blog/2020/03/15/js-time/js-time.jpg" class title="This is an js-time image">
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/15/js-time/" data-id="cka55razv000juwu1hs7h64l0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/15/DOM/" class="article-date">
  <time datetime="2020-03-15T13:53:27.000Z" itemprop="datePublished">2020-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/15/DOM/">DOM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>DOM底层已总结完毕</p>
<img src="/blog/2020/03/15/DOM/DOM.jpg" class title="This is an DOM image">
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/15/DOM/" data-id="cka55raz30009uwu135ss6xwz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-bascis-MindMater" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/11/js-bascis-MindMater/" class="article-date">
  <time datetime="2020-03-11T15:21:43.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/11/js-bascis-MindMater/">js-bascis-MindMater</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>复习期间js底层原理持续更新中…</p>
<img src="/blog/2020/03/11/js-bascis-MindMater/js-basics.jpg" class title="This is an js image">

<p>(需要细节MindMaster或技术讨论欢迎加QQ分享:572481466)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/11/js-bascis-MindMater/" data-id="cka55raz8000euwu1hz6hb78x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-html-css-basics-sunmmary" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/11/html-css-basics-sunmmary/" class="article-date">
  <time datetime="2020-03-11T03:56:37.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/11/html-css-basics-sunmmary/">html-css-basics-sunmmary</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <img src="/blog/2020/03/11/html-css-basics-sunmmary/htmlcss.jpg" class title="This is an htmlcss image">
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/11/html-css-basics-sunmmary/" data-id="cka55raz6000buwu1cffs16mx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-12-RegExp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/11/js-basics-12-RegExp/" class="article-date">
  <time datetime="2020-03-11T02:46:51.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/11/js-basics-12-RegExp/">js-basics-12-RegExp</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RegExp 正则表达式</p>
<p>正则表达式的作用：匹配特殊字符或有特殊搭配原则的字符的最佳选择。<br>RegExp 对象表示正则表达式，它是对字符串执行模式匹配的强大工具（判断字符串满不满足要求）。正则表达式其他语言也有，规则是一样的，在这个基础上，js 增加了自己独特的方法。<br>例</p>
<p>㈠. 基础语法<br>创建一个正则表达式<br>第一种方法：正则表达式字面量//    【推荐使用这种】例 var reg = /pattern/;</p>
<p>例：意思是正则表达式测验一下字符串含不含有我规定的片段</p>
<p>例像下面这种，虽然都有 abce，但是没挨着，或者排序不对，都不算</p>
<p> 第二种方法：new RegExp();<br>var reg = new RegExp(“pattern”);<br>例：括号里面写的是规则</p>
<p>例下面是给正则表达式增加属性的方法：</p>
<p>例在正常情况下，下面两个虽然是形式一样，但是是两个不同的正则表达式</p>
<p>^a 的意思是必须是这个 a 开头，那么下面这串就只有一个例</p>
<p>例因为上面这种写法没有多行匹配的功能，直到给他加上了 m</p>
<p>上面这三种方法还能组合到一起，例 var reg = /abce/igm;<br>正则表达式的表达式：<br>reg.test( ); 只能判断这个字符串有没有符合要求的片段，返回结果只有 true 和false str.match( ); 可以把所有东西都匹配出来，返回给你，比上一种方法更直观，还能告诉你返回了多少个<br>例：想把第一、二、三位都是数字都匹配出来，不同，可变化的数字，可以用[]来写， 一个[]代表一位数，[]里面放的是范围，是一个区间，如[1234567890，如下图：</p>
<p>例<br>例 0-9 是指 0 到 9，A-Z 是指大A 到大 Z，a 到 z 是指小 a 到小 z</p>
<p>这个是按照 ASC 码排序的，从大写到小写可以写成A-z</p>
<p>例^在表达式里面和外面的意思是不一样的，在里面是非的意思</p>
<p>i 是 ignoreCase，是忽视大小写的意思，例 var reg = /abce/i;<br>g 是全局匹配的意思，例 var reg = /abce/ g;<br>m 执行多行匹配，例 var reg = /abce/ m;<br>例</p>
<p>例正则表达式中 | 是或的意思，下面是匹配 abc 或bcd</p>
<p>正则表达式的元字符和表达式是一个东西<br> 元字符（Metacharacter）是拥有特殊含义的字符：<br>\w 代表一位，w 意思是 world， \w===完全等于[0-9A-z_]<br>\W === [^\w]    大写\W 是非的\w<br>例</p>
<p>例下面的    是一个制表符\t 打出来的，但是系统是不能识别的要写成以下形式才能识别\t<br>例\r 匹配回车</p>
<p>\d === [0-9]<br>\D ==== [^\d] ， \D ==== [^0-9]<br>例<br>表达式里面可以写元字符<br>\s === [空白字符，即\t\n\r\v\f ]    最常用的是空格和换行<br>在正则表达式中写空格就代表空格<br>\S ==== [非空白字符]</p>
<p>\b === 单词边界<br>\B ==== 非单词边界<br>单词边界在字符串里面可以看成 （空格）<br>例下面 str 有六个单词边界，写成 var reg = /\bc/g;意思是 c 前面要有一个单词边界</p>
<p>例 cde 前面要是一个单词边界，后面也要上一个单词边界</p>
<p>例</p>
<p>\uxxxx    这是简单的四位的Unicode 编码（包含了汉字）<br>查找以十六进制数 xxxx 规定的 Unicode 字符。<br>还有六位数 Unicode 编码（前两位代表的是层，后面代表的是范围）<br>\u010000 - \u01ffff      第一层 Unicode 编码的区间<br>\u020000 - \u02ffff      第二层 Unicode 编码的区间<br>\u100000 - \u10ffff   第十六层Unicode 编码的区间经常用的是第一层，一般会忽略 01，写成\uxxxx。例<br>例 Unicode 编码也可以写成区间，如下</p>
<p>注意：代表一切的集合var reg = /[/s/S]/;或者/[/d/D]/这样类似的</p>
<p>例<br>正则表达式的量词（代表数量的词）<br>匹配任何包含至少一个 n  的字符串。这个变量可以出现 1 到无数次。匹配任何包含零个或多个 n 的字符串。这个变量可以出现 0 到无数次。<br>n 是一个变量，n+代表这个变量可以重复出现 1 次到无数次，n*代表{0 到正无穷} 例</p>
<p>光标在 c 后面，c 后面有逻辑上的距离，<em>如果是零，匹配的是空。\w 会先把能识别<br>值的先识别，到最后识别不了，才试一下</em>零，匹配空</p>
<p>例</p>
<p>因为光标在 a 前面，逻辑上有距离，匹配了一个零，空串；然后光标移动 a 后面， 逻辑上有距离，又匹配了一个零，空串，所以有多少个光标定位点就有多少个<br>例<br>正则表达式有一个贪婪匹配原则，能多就不少<br>n?    匹配任何包含零个或一个 n 的字符串。这个变量 0 或 1 个一匹配。<br>例最后会匹配一个空</p>
<p>n{X}    匹配包含 X 个 n 的序列的字符串。<br>例如 n{3}就是三个三个一匹配</p>
<p>例以 ed 结尾</p>
<p>例</p>
<p>上面这道题应该理解成：以当前这个 abc 开头，以这个 abc 结尾的字符串例<br>作业：写一个字符串，检验一个字符串首尾是否含有数字。<br>首尾都含有的意思是需要加“都”；首尾的意思是首有，或，尾有<br>答案<br>如果是首和尾都有：</p>
<p>n{X,Y}    匹配包含 X 至 Y 个 n 的序列的字符串。<br>例下面要符合贪婪匹配原则，/\w{3,5}/就是能 5 个就不 4 个，能 4 个就不 3 个</p>
<p>n{X, }       匹配包含至少 X  个 n  的序列的字符串。例/\w{1,}/ {1,}和 n+是一样的，指匹配 1 到无数个。例/\w{2,}/ {2,}是匹配 2 到无数个<br>思考：量词，量的是什么？<br>答案：n*是 n 乘以这个量词，/\w{2,}/不是\w 的结果乘以量词，如果\w 的结果乘以这个量词，那么匹配的都是一致的。量词量的是 w，是\w 乘很多东西，再每个w 再随机匹配。而不是\w 先匹配结果，再乘以量词（例如先匹配一个 a，再乘以那么多a 就匹配不成来了，所以不能这么理解）<br>例<br>n$    匹配任何结尾为 n 的字符串。<br>例<br>例^abc 是以a 开头的 abc</p>
<p>例$是以 d 结尾，这个匹配不出来</p>
<p>111</p>
<p>例如果把游标归 0</p>
<p>例如果不加 g，lastIndex 就不会动，如下</p>
<p>例说明他在第一个 ab 后面接着匹配</p>
<p>例：游标的属性是 lastIndex。lastIndex 是为了 exec 而存在的</p>
<p> 拓展知识<br>例 var str =  “aaaa”;    //想要匹配四个一样 xxxx 的<br>var reg = /( a )/g;    //这个括号还有一个子表达式的意思，正常来说括号写了没有用，也没影响，但是在特殊情况，当你把式子当特殊括起来以后，这个括号会记录里面匹配的内容，记录完以后利用\几可以反向引用出来，如下<br>var reg = /( a )\1/g;     //这个\1 意思是反向引用第一个子表达式里面的内容，这里的意思是匹配 a 和后面同样的a<br>如果换成 var reg = /( \w )\1/g; //意思就变成了\w 匹配出来的东西，后面要 copy 一个一样的<br>例想要匹配四个一样的写法如下：</p>
<p>例例<br>例现在想匹配出 aabb，应该怎么写？/(\w)\1(\w)\2/里面\1 是反向引用第一个表达式里面的内容，(\w)\2 是反向引用第二个表达式里面的内容。</p>
<p>上面多出了第一个字表达式和第二个子表达式的内容，而且是正式的数据位，虽然<br>是类数组，但是能当数组用。</p>
<p>例就算不加 g，也会这样匹配出来，只是不改变index    例</p>
<p>例 match    找到一个或多个正则表达式的匹配。</p>
<p>例如果写()子表达式就会把子表达式的东西返回，如果不写就不能反向引用了<br>例但是加 g 了以后，只把匹配了多少个给你</p>
<p>例 search    检索与正则表达式相匹配的值。<br>返回的不是-1 都匹配成功了，返回的是匹配的这个东西的位置</p>
<p>例加不加 g，没有区别</p>
<p>例如果匹配不到就返回-1</p>
<p>split    把字符串分割为字符串数组。<br>例：按双重复的拆分（加不加 g 返回都一样）。下面这种失败</p>
<p>replace    替换与正则表达式匹配的子串。    非常实用例</p>
<p>上面是非正则表达式的缺点，想要返回 bb，但是返回的是 ba。没有返回全局的能力。例</p>
<p>例</p>
<p>replace 的精华是正则表达式<br>例：想把 aabb 匹配出来，再倒过来<br>答案方法一</p>
<p>上面 str.replace(reg,””)替换的信息不管写什么都要写成字符串，字符串里面“$1”代表第一个子表达式的内容，“$2”代表第二个子表达式的内容<br>方法二，写成 function，而 function（，  ，）{}里面传的第一个参数是正则表达式匹配的全局（结果）（可随便起名），第二个参数是第一个表达式匹配的内容，第三个参数是第二个表达式匹配的内容（写 return$1$2 不适合语法）</p>
<p>例 var reg = /a{1,3}?/g;    //这个 1 到 3，意思是有 1 就不取 2，3<br>思考：如果在量词是??<br>例 var reg = /a??/g;    //??第一个问号代表量词，第二个问号叫取消他的匹配，第一个问号是 0-1 的意思，加个问号就是能取 0 就不取 1<br>*?意思是能取 0 就不取多<br>例</p>
<p>例把 the-first-name 变成小驼峰式写法theFirstName<br>思路：是把-f 变成 F，把-n 变成N，先匹配再转换</p>
<p>答案</p>
<p>上面的 function 匹配了多少次，就有多少次 function 的执行，而上面的 reg 找了两次， 找一次匹配一次<br>正向预查/正向断言<br>?=n    匹配任何其后紧接指定字符串 n  的字符串。例我要选一个 a，后面跟着b，就是正向预查/正向断言</p>
<p>/a(?=b)/意思是 a 后面跟着b，但是 b 不参与选择<br>?!n    匹配任何其后没有紧接指定字符串 n 的字符串。后面不跟着n<br>例后面不跟着 b 的 a</p>
<p>下面是正则表达式讲义内容：<br>贪婪匹配，变成非贪婪匹配（能少就不多），在量词后面加个?<br>例</p>
<p>注意：<br>1、想匹配空格，直接写 就可以了<br>2、想把选中的字符替换成$，直接写$是不行的，需要加上转义字符$<br>由于在替换文本里$有了特殊的含义（$代表反向引用），如果想要是替换$这个字符的话，需要写成$$，充当成转义字符<br>3、正则表达式要匹配一个反向引用的东西，写\<br>例</p>
<p>4、在正则表达式里面要匹配问号？写\？    其余*+-（）星号加号减号括号都类似例<br>例下面是想去重，变成abc，先匹配一串，再取一例百度招聘 14 年最后一题：<br>给 var str =  “100000000000”;    这个数字科学计数法，每隔三位打个点<br>思路：找规律，从后往前查，每三位打个点，换个空进去【什么样的空？后面的数一定是 3 的倍数，(\d{3})+是 3 的倍数位个数字，这里面的东西一到多个，第一个/<br>后面的空后面加上正向预查，后面是 3 的倍数位个数字，$以什么结尾】空的后面跟着 3 的倍数位个数字并且以这个结尾。\B 非单词边界</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/11/js-basics-12-RegExp/" data-id="cka55rb00000luwu1580d2sgw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-11-function" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/11/js-basics-11-function/" class="article-date">
  <time datetime="2020-03-11T02:42:36.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/11/js-basics-11-function/">js-basics-11-function</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>function<br>重点：事件处理程序的运行环境，如何解除事件处理程序，事件处理模型（冒泡，捕获），阻止默认事件，事件对象，事件委托，事件分类</p>
<p>1、ele.onxxx = function (event) {}<br>程序 this 指向是 dom 元素本身（指向自己）</p>
<p>、obj.addEventListener(type, fn, false);<br>程序 this 指向是 dom 元素本身（指向自己）</p>
<p>解除事件处理程序<br>1、ele.onclick = false/‘’/null;    ==&gt;    解除 ele.onxxx = function (event) {}<br>2、ele.removeEventListener(type, fn, false);==&gt;解除 addEventListener(type, fn, false) 3、ele.detachEvent(‘on’ + type, fn);    ==&gt; obj.attachEvent(‘on’ + type, fn);<br>注:若绑定匿名函数，则无法解除<br>例用 div.onclick = null;解除事件，</p>
<p>3、obj.attachEvent(‘on’ + type, fn);<br>程序 this 指向window<br>例让 obj.attachEvent 指向自己，function handle(){}里面是事件处理程序</p>
<p>例只能执行一次的事件的写法</p>
<p>4、封装兼容性的 addEvent(elem, type, handle);方法（必须会）<br>addEvent 是给一个 dom 对象添加一个该事件类型的处理函数例</p>
<p>例 ele.removeEventListener(type, fn, false);    1、事件冒泡：</p>
<p>结构上存在父子关系的元素，如果点击到子元素，会一级级向父元素传递这个事件<br>（从代码的角度是自底向上一层层冒泡的）<br>例加了 margin，只点黄色的，还是出现了 box,content,wrapper。所以与视觉无关</p>
<p>test 如果填 function(){}别人就找不到他，就没办法清除，所以此时的函数体要写在外面<br>例 ele.detachEvent(‘on’ + type, fn);清除绑定时一摸一样的 obj.attachEvent(‘on’ + type,<br>fn);</p>
<p>事件处理模型 — 事件冒泡、捕获事件处理的两个模型：事件冒泡、捕获（不能同时存在） 例</p>
<p>2、事件捕获：（只有谷歌有，最新火狐有）</p>
<p>2）IE 没有捕获事件<br> 一个对象的一个事件类型，只能存在一个事件处理模型（冒泡或捕获）<br>obj.addEventListener(type, fn, true);第三个参数为true 就是事件捕获<br>例点击黄的：先红的捕获事件并且执行，再绿的捕获事件并且执行，最后只执行事件黄的。捕获是把结构的最外面先抓住。最外面先捕获，再一层层向里面捕获，最里面的是按常规执行。<br>例把 false 改成 true，就变成了事件捕获<br>html 部分沿用左侧冒泡情况的代码，只把 false 改成 true 就变成事件捕获了</p>
<p>只点了黄色区域，但是出现了 box,content,wrapper，往下漏了，就是事件冒泡</p>
<p>思考：同一个对象的同一个事件类型，上面绑定了两个事件处理函数，一个符合冒泡，一个符合捕获，点击一个元素后，是先捕获，还是先冒泡？<br>3、触发顺序，先捕获，后冒泡</p>
<p>取消冒泡和阻止默认事件<br>例不给 div 绑定事件处理函数，依然会冒泡（document 冒泡到 div 上）</p>
<p>例 html 部分沿用上一页冒泡情况的代码</p>
<p>例给 div 也帮个事件（点红色，也冒泡到 document）</p>
<p>在每一个事件处理函数中【div.onclick=function(){}】，我们可以写一个形参（如 e），系统可以传递事件对象（记载了数据发生时的状态和信息）到这个参数里面去</p>
<p>例    改变了冒泡和捕获的顺序</p>
<p>1）W3C 标准 event.stopPropagation();但不支持 ie9 以下版本<br>例事件对象上有一个 event.stopPropagation();取消冒泡事件</p>
<p>2）IE 独有 event.cancelBubble = true;【实际上谷歌也实现了】<br>例 ie 里面事件对象上有一个 event.cancelBubble = true;能取消冒泡事件</p>
<p>这个的顺序是先捕获红色，再捕获绿色，boxBubble 黄色区域事件执行，box 黄色区域事件执行，冒泡到绿色，冒泡到红色（谁先绑定，谁先执行，boxBubble 先绑定， 所以先执行）<br>4、focus，blur，change，submit，reset，select 等事件不冒泡</p>
<p>3）封装取消冒泡的函数 stopBubble(event)</p>
<p>3）event.preventDefault(); W3C 标注，IE9 以下不兼容<br>例</p>
<p>4）event.returnValue = false; 兼容 IE<br>例</p>
<p>5）封装阻止默认事件的函数 cancelHandler(event);<br>例</p>
<p>例浏览器点右键出菜单，是一个事件（默认事件）</p>
<p>例 a 标签有一个跳转的默认时间，如何取消看下面</p>
<p>2）return false;    兼容性非常好，以对象属性的方式注册的事件才生效（这是句柄的方式阻止默认事件，只有句柄的方式绑定事件才好使）<br>例</p>
<p>ele.onxxx = function (event) {}是句柄的绑定方式，才能用 return false;</p>
<p>2、事件源对象:（找事件源对象的方法） event.target    火狐独有的event.srcElement    Ie 独有的<br>这俩 chrome 都有<br>例事件源对象的兼容性写法</p>
<p>事件委托<br>例我们给每个 li 绑定事件，要求点哪个 li 就输出哪个内容，这不涉及闭包问题</p>
<p>上面的写法不好（如果是三千亿个 li 就没效率），不能动态，要用事件源和事件冒泡</p>
<p>事件委托：利用事件冒泡，和事件源对象进行处理优点：<br>1.性能  不需要循环所有的元素一个个绑定事件<br>2.灵活  当有新的子元素时不需要重新绑定事件<br>例给每个 li 绑定事件，再增加 li 也能使用</p>
<p>扫雷的雷也可以放 ul 上<br>作业：预习下面的三个词，写拖拽功能（鼠标按住方块跟着动，松开就不跟着走）<br>答案</p>
<p>上面这个写法有问题，鼠标在方块的左上角，不在你点击他时候的位置</p>
<p>思路：上面是把点击鼠标的点设置成方块的 left 和 top（就是把鼠标的点设置成了左顶点，这样就少了个距离），我们把这个距离算上就可以了，加上鼠标第一次点击时候的离方块上边和左边的距离再赋给左上角了<br>之前是把 div.onmousemove 写在div 上面，有一个 bug，我们按住鼠标迅速离开方块，方块就不会跟着动，一直按住鼠标，再一进去，又可以带着方块动了，是一个事件监听的问题（鼠标挪动频次大于事件监听频次），我们写成 document.onmousemove就可以了</p>
<p>上面这个写的很粗糙，没有封装也没有绑定。document.onmousemove=function(){}这种写法是不可以的，要用 addEventListener 绑定。作业就是把上面绑定成函数，函数名叫 function drag (elem) {}<br>例</p>
<p>面试问题，什么是事件捕获，一个是冒泡，一个是捕获 obj.addEventListener(type, fn, true);他所说的第二种捕获不是事件处理模型，而是一种真实的事件获取的过程，用于解决拖拽鼠标出方块的问题<br>仅在 ie 好使，利用 div.setCapture();会捕获页面上发生的所有事情，都获取到自己身上。对应的用 div.releaseCapture();释放。但是方法比较老旧，一般不用。</p>
<p>例 click 不能监听右中</p>
<p>4、如何解决 mousedown 和 click 的冲突</p>
<p>click、mousedown、mousemove、mouseup、contextmenu、mouseover、mouseout、mouseenter 、 mouseleave<br>例 click=mousedown+mousemove</p>
<p>这三个事件的触发顺序是mousedown，mouseup，click<br>例 contextmenu 右键取消菜单，mousemove 是鼠标移动的事件<br>例相对应 mouseover、mouseout 鼠标覆盖区域与 mouseenter 、mouseleave 鼠标离开但是 mouseenter 、mouseleave 是 html5 的，都是鼠标进去，出来发生的变化</p>
<p>2、用button 来区分鼠标的按键，0/1/2<br>只有 mouseup、mousedown 两个能区分鼠标垫左右键<br>button 返回值，右键是 0，左键是 2，中间是 1<br>例</p>
<p>事件练习作业<br>1、拖拽应用：实现拖拽正常拖，但是点击就正常跳转<br>思路：拖拽由 down+move+up，但是不管隔多久都算一个 click，可以理解成拖拽不等于点击 click。看时间差解决：按下+抬起的时间差&gt;多少，就能知道是拖拽了。答案：按下之后才绑定move 事件，抬起了 move 事件就解除</p>
<p>2、应用 mousedown mousemove mouseup 3、随机移动的方块（完全随机）<br>思路：当把鼠标挪到方块里面去onmouseover 的时候，方块随机向八个方向挪动<br>4、mouseover<br>移动端 onmousedown 不能用，只能用 touchstart,touchmove,touchend</p>
<p>1、keydown，keyup，keypress</p>
<p>事件分类</p>
<p>例 change 对比鼠标聚焦，或失去焦点的时，两个状态是否发生改变，如果两个状态没有改变就不触发，如果发生改变就触发</p>
<p>2、触发顺序是 keydown &gt; keypress &gt; keyup</p>
<p>keydown 可以响应任意键盘按键，keypress 只可以相应字符类键盘按键<br>检测字符类不准确，keypress 检测字符很准。但是 keydown 能监控所有，包括上下左右都能监控，但是 keypress 只能监视字符。<br>用法：如果你想监控字符类按键，并想区分大小写，就用 keypress，如果是操作类按键的话，就用 keydown（which：39 是给按键牌号 39，不是 asc 码）<br>2）keypress 返回ASCII 码，可以转换成相应字符<br>例连续按键盘按键的时候就是连续触发 keydown 和keypress，松开触发keyup</p>
<p>注意：游戏触发设置在 keydown 上，机械键盘抬起速度快反馈力量大，对游戏没用<br>小写的 a 的 charCode 返回的是<br>例利用下面，把 Unicode 编码转成对应值</p>
<p>二、文本操作事件<br>input，change，focus，blur</p>
<p>例 focus，blur 聚焦和失去焦点</p>
<p>三、窗体操作类(window 上的事件)    scroll，load<br>例 scroll 当滚动条一滚动，scroll 事件就触发了</p>
<p>ie6 没 fixed 定位，就用 position 的 top=原来的 top+滚动条的位置来写。absolute 定位相对于文档定位，用absolute 定位模拟 fixed 定位，挪动距离加载absolute 的 top 上读到 js 的时候就阻断页面，所以必须把 js 写在下面才能把上面的东西读出来。<br>例 load 重要但是不用。window.onload 发生在什么时候</p>
<p>利用了 onload 就能操作写在下面的 div 了，但是我们不能这样用。<br>理由：html 和 css 是一起解析的，在解析的时候会有 html 有 domTree，css 有 cssTree 生成（树形图的顶底是document，然后是html，然后是 head，body），两个树拼在一起是 renderTree。</p>
<p>什么时候把节点放在树里？dom 节点解析，如确定是 img 标签就把他放到树里。（先解析完 img，同时开启一个线程异步的去下载里面的内容，后下载完）。<br>我们把 js 的 script 标签写在最下面的好处是，这些刚刚解析完 js 就能操作页面了， 就更快了。而 window.onload 要等整个页面解析完，下载完才能操作 js，才能触发事件（效率很差）。onload 能提醒我们什么时候整个页面解析完毕。在设计广告时，就要用 onload，等整个页面下载完了才开始用，但是onload 绝对用于主程序里面。</p>
<p>小练习:fixed 定位 js 兼容版    //ie6 没有 fixed 定位，用 position:absolution 是相对于文档定位。模拟fixed 定位，跟着解决文档拖的问题。position-top= 原来的position-top</p>
<ul>
<li>滚动条的位置</li>
</ul>
<p>作业<br>1、完善轮播图，加按钮    //提示：用留的接口，加两个按钮，改参数<br>2、提(qie)取密码框的密码    //提示：监听键盘事件<br>3、输入框功能完善<br>4、菜单栏（二阶菜单栏）    //提示：先写一个 div，开始的时候 display：none，等鼠标挪上去，变成 display：block</p>
<p>5、贪食蛇游戏    //提示：蛇头动，蛇尾怎么跟着动，控制蛇头操作就可以了，蛇尾的每一节跟着前一节动<br>6、扫雷游戏    //注意闭包，有个扩散算法。<br>二维数组就是数组里面套数组(像矩阵)，可以表示坐标点<br>arr[1][1]说的是第二行第二列，也就是 22</p>
<p>可以尝试做：球击方块（板子）的游戏</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/11/js-basics-11-function/" data-id="cka55rb01000muwu1ctqw6rt2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-10-dom" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/11/js-basics-10-dom/" class="article-date">
  <time datetime="2020-03-11T02:36:04.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/11/js-basics-10-dom/">js-basics-10-dom</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>DOM</p>
<p>重点：dom操作，节点替换，节点封装</p>
<p>在 es3 里面重复的参数是不报错的，但是在 es5 里面是会报错的<br>h<br>表示和修改文档所需的方法（对象、这些对象的行为和属性以及这些对象之间的关系。）DOM 对象即为宿主对象，由浏览器厂商定义，用来操作html 和 xml 功能的一类对象的集合。<br>也有人称DOM 是对 HTML 以及 XML 的标准编程接口。<br>xml    ==&gt;    xhtml    ==&gt;    html<br>xml 是最早的版本，xml 里面的标签是可以自定义的，被 js 里面的Jason 取代了<br>dom 不能改变 css 样式表,可以间接改变行间样式的 css</p>
<p>例：说的改变不了 css 是指改变不了css 的样式表，但是可以通过间接方式改变html<br>的行间样式来改变</p>
<p>1、找到 html 的方法：如 document.getElementsByTagName(‘div’)就能把所有的 div<br>都选出来。<br>如果想拿到第一个 div，写成 document.getElementsByTagName(‘div’) 后面就要加一个[0];就可以实现了<br>2、div.style 选出来代表行间样式，选出来的就是 dom 对象<br>3、js 不能写-，只能用小驼峰方法写。如background-color 写成 backgroundColor<br>例<br>有 dom 操作以后就变成动态交互可以操作的了（你动一下，他给你一个反应）<br>div.onclick 是加一个交互效果的事件监听</p>
<p>例实现点击一下改变一下</p>
<p>例写个选项卡，点第一个按钮出现第一对应的信息，点第二个按钮，第一个消失， 出现第二个的信息</p>
<p>下面的 button 就是个按钮</p>
<p>例写个小方块应用<br>document.body.appendChild(div);意思是在 body 里面放个 div<br>setInterval(function () {},100);是一个定时器功能，意思是每隔 100 毫秒就执行一次</p>
<p>把上面 setInterval(function){}改成以下样式：</p>
<p>最好用下面这种立即执行函数的写法：</p>
<p>把最上面 setInterval(function){}改成以下样式，可以让定时器停止</p>
<p>例 点了加速的按钮以后，移动的速度变快</p>
<p>例：现在要实现按住加速，不好写没写，看 js 运动课</p>
<p>按住加速：就是这一次按下与下一次按下的速度间隔时间十分短暂，就认为他加速了。<br>上面思路：每一次按下的时候都记录一个新的时间片段，都减去上一个执行的时间片段，如果时间片段都小于一定的毫秒数的话，我们让一个计数器去++，当连续小于的时候，就让计数器连续++,如果++到一定数的时候，我们认为是连续按了，再按就加速了，让每一次按的时候都判断一下,如果时间间隔过大的话，就让计数器重新归 0。——在 js 运动课里面讲</p>
<p>例 box-sizing:border-box;启动了另外一种盒模型</p>
<p>中间有<li img-date="”0”"></li>*400，onmouseover 是鼠标滑过变成</p>
<p>把左边的案例，如图去掉边线</p>
<p>emmet 插件提供的方法：（打字操作）例 div*3<br>例 div.demo 就是直接设置了 class 名字例 div.demo#only<br>例 div.demo#only</p>
<p>例 div.demo#only &gt; p[style=’background-color:red;width:100px;height:100px;’]</p>
<p>例 div&gt;(p^span.demo)<br>例加内容就用{}花括号<br>div&gt;(p^span.demo{123})</p>
<p>例 ul&gt;li{$}<em>10 这里面的$代表变量    ============&gt;<br>例 ul&gt;li{$</em>2}*10    ============================&gt;<br>可以看看 emmet 插件教程<br>在安装插件之前要按一个package control，在百度里面找，复制代码后，按 ctrl+~再把复制的代码粘贴到这里，按回车就可以了<br>在sublime text 里面preferences 里面找到package control，在搜索框找到install package<br>后打 emmet，Jsprettify（整理排序用的）<br>编辑器还有 vscode，webstrom，atom</p>
<p>DOM 基本操作(大部分都是类数组)——方法类操作1.对节点的增删改查    ()括号里面都不用写.或#<br> 查<br> 查看元素节点<br>document 代表整个文档（如果给 html 标签上面再套一层标签就是 document） document.getElementById() //元素 id 在 Ie8 以下的浏览器，不区分 id 大小写，而且也返回匹配 name 属性的元素，通过 id 标识我们来选择这个元素，一一对应<br>例</p>
<p>除了 id 以外，其余选择出来的都是一组，很少用 id 选择器<br>.getElementsByTagName()    //标签名，这是一个类数组，最主流的用法，经常用<br>例把页面里面所有的 div 都选择出来</p>
<p>从 dom 开始，我们所学的一切系统给我们生成的成组的东西，基本上都是类数组例加个[0]就选中了第一个div，如果不加 0，那个 div 表示的是一个数组，设置背景颜色就会报错</p>
<p>例把下面所有的div 都拿出来</p>
<p>只拿出第二个 div，加上[1] ，或者在控制台上打 div[1]<br>例选择第一个 p 的方式如下</p>
<p>例只拿出 demo 的 p 标签写法如下：</p>
<p>注意哪怕整个文档只有一个demo，也要加[0]，不然选出来的就是一个组</p>
<p>getElementsByName(); //IE 不支持需注意，只有部分标签 name 可生效（表单，表单元素，img，iframe），不是在所有的浏览器都能用——开发一般不用<br>例</p>
<p>.getElementsByClassName()    // 类名 -&gt;缺点： ie8 和ie8 以下的 ie 版本中没有，可以多个 class 一起，不是所有浏览器都能用<br>.querySelector()    // css 选择器，只能选一个，在 ie7 和 ie7 以下的版本中没有<br>.querySelectorAll()    // css 选择器，全选，选一组，在 ie7 和 ie7 以下的版本中没有<br>.querySelectorAll()和.querySelector()选出来的元素不是实时的（是静态的），所以一般不用，其他的再怎么修改，跟原来的没有关系<br>id 选择器不能太依赖，一般当顶级框架存在，在 css 中一般用 class 选择器<br>query 是一个词条</p>
<p>例.querySelector()和.querySelectorAll()选出来的元素不是实时的，是静态的，是副本</p>
<p>DOM 基本操作——非方法类的操作<br> 遍历节点树：(灵活，兼容好)——关系类的选择<br>parentNode  → 父 节点    (最顶端的 parentNode 为#document);<br>childNodes → 子节点们（直接的节点数）节点包括文本节点，属性节点<br>firstChild → 第一个子节点lastChild → 最后一个子节点nextSibling →后一个兄弟节点previousSibling → 前一个兄弟节点</p>
<p>例 parentNode → 父节点</p>
<p>下面的都是实时的</p>
<p>childNodes → 子节点们</p>
<p>例.querySelectorAll()选中了所有的 div，但是实时操作不能实时反馈</p>
<p>节点为什么是 7？<br>答案第一个节点是<div>后面的文本节点（空格回车），第二个节点是元素节点<br><strong><span>1</span></strong>，第三个节点是跟着的文本节点（空格回车），第四个节点是<span></span>，第五个是跟着的文本节点（空格回车），第六个是<em></em>，第七个是跟着的文本节点（空格回车）</div></p>
<p>后面的数字是调用 nodeType 返回的数字<br>元素节点    ——    1<br>属性节点    ——    2    （基本没用，）<br>文本节点    ——    3<br>注释节点    ——    8<br>document    ——    9<br>DocumentFragment    ——    11</p>
<p>答案七个，第一个节点是<div>后面的文本节点（空格回车），第二个节点是注释节点，第三个节点是跟着的文本节点（空格回车），第四个节点是元素节点<br><strong></strong>，第五个是跟着的文本节点（空格回车），第六个是<span></span>， 第七个是跟着的文本节点（空格回车）</div></p>
<p>答案七个，123 和空格等是一个文本</p>
<p>例 nextSibling →后一个兄弟节点 ，previousSibling → 前一个兄弟节点</p>
<p> 基于元素节点树的遍历（不含文本节点）<br>（除 children 外，其余 ie9 及以下不兼容）<br>parentElement -&gt; 返回当前元素的父元素节点 (IE 不兼容) 例</p>
<p>例 children -&gt; 只返回当前元素的元素子节点</p>
<p>例 nextElementSibling / previousElementSibling -&gt;返回后一个/前一个兄弟元素节点<br>（IE 不兼容)</p>
<p>例 node.childElementCount    === node.children.length 当前元素节点的子元素节点个数(IE 不兼容)——基本不用，因为与 length 相等<br>例 firstElementChild -&gt; 返回的是第一个元素节点(IE 不兼容) lastElementChild -&gt; 返回的是最后一个元素节点(IE 不兼容)</p>
<p>除 children 外，parentElement、node.childElementCount、firstElementChild、<br>lastElementChild、nextElementSibling、 previousElementSibling 在 ie9 及以下不兼容<br>真正常用的就是children，兼容性好</p>
<p>1、nodeName</p>
<p>每一个节点的四个属性</p>
<p>数字是调用 nodeType 返回的数字元素节点    —— 1</p>
<p>元素的标签名，以大写形式表示,只读，不能写<br>例 nodeName</p>
<p>属性节点    —— 2    （基本没用，class=“demo”就是一个属性节点）<br>文本节点    —— 3<br>注释节点    —— 8<br>document    —— 9<br>DocumentFragment    ——    11<br>例把 div 下面所有的直接子元素节点挑出来，放在数组里面返回，不能用 children</p>
<p>2、nodeValue<br>Text 文本节点或 Comment 注释节点的文本内容,可读写</p>
<p>3、nodeType（最有用）<br>该节点的类型，只读返回这个 div 的所有的元素节点</p>
<p>4、attributes<br>Element 节点的属性集合<br>例</p>
<p>例当且仅当这种情况下是false（没空格，没回车）</p>
<p>例属性的节点是div 上面的，不是 div 里的</p>
<p>DOM 接口<br>dom 结构树代表的是一系列继承关系</p>
<p>属性名不能改，属性值可以改，但是我们一般不用这种方法我们一般用 getAttribute 和setAttribute 去取<br> 节点的一个方法 Node.hasChildNodes();——他有没有子节点，返回值是 true 或 false</p>
<p>document 继承自 HTMLDocument.prototype。HTMLDocument.prototype 继承自 Document.prototype</p>
<p>DOM 基本操作<br>1.getElementById 方法定义在 Document.prototype 上，即Element 节点上不能使用。2.getElementsByName 方法定义在 HTMLDocument.prototype 上，即非 html 中的document 以外不能使用(xml document,Element)<br>3.getElementsByTagName 方法定义在 Document.prototype 和 Element.prototype 上例选 div 里的 span</p>
<p>开发中，经常利用先选择的父级，在他父级里面再次选什么元素来定位一个元素例</p>
<p>4.HTMLDocument.prototype 定义了一些常用的属性，body,head,分别指代 HTML 文档中的<body><head>标签。<meta name="generator" content="Hexo 4.2.0"></head></body></p>
<p>5.Document.prototype 上定义了 documentElement 属性，指代文档的根元素，在 HTML<br>文档中，他总是指代<html>元素</html></p>
<p>6.getElementsByClassName、querySelectorAll、querySelector 在Document,Element 类中均有定义<br>作业 1.遍历元素节点树，要求不能用 children 属性（在原型链上编程）<br>答案：低级方法，给一个父节点，把子节点全部遍历出来，并打印<br>高级方法：打印树形结构 → 分层打印出来<br>先看 div 再看子元素节点， 再挨个判断</p>
<p>2.封装函数，返回元素 e 的第 n 层祖先元素</p>
<p>3.封装函数，返回元素 e 的第 n 个兄弟节点，n 为正，返回后面的兄弟节点，n 为负， 返回前面的，n 为 0，返回自己。<br>答案</p>
<p>上面在 ie9 以下不能用。考虑到兼容性，可以按照下面思路写</p>
<p>1 是元素节点的返回值，用for 循环和三目运算：</p>
<p>如果 for（）{}循环的执行体是空的，那么可以不写{}</p>
<p>4.编辑函数，封装 children 功能，解决以前部分浏览器的兼容性问题<br>答案</p>
<p>1、增</p>
<p>DOM 基本操作</p>
<p>document.createElement();    //增加或创建元素节点（标签）——常见<br>例在括号里面写什么字符串，就创建什么标签</p>
<p>左上加了 123，但是页面里面没有显示，用右上方法即可document.body.appendChild(div) document.createTextNode(); //创建文本节点<br>document.createComment();   //创建注释节点<br>document.createDocumentFragment();    //创建文档碎片节点，最后讲</p>
<p>5.自己封装hasChildren()方法，不可用children 属性<br>答案</p>
<p>2、插——剪切操作PARENTNODE.appendChild();    可以理解成.push</p>
<p>例选择我们把邓宝宝插入到 span 里面去</p>
<p>例在 div 后，span 前插入 strong</p>
<p>例在 div 后，span 前插入 strong 的基础上，把 i 放 strong 前面</p>
<p>3、删</p>
<p>例把 span 放div 里面</p>
<p>4、替换<br>parent.replaceChild(new, origin);    //用新的 new 去置换旧的origin</p>
<p>PARENTNODE.insertBefore(a, b);一定是 div 先 insert a，before b<br>例</p>
<p>strong 插入效果见右侧</p>
<p>1、Element 节点的一些属性</p>
<p>DOM 基本操作</p>
<p>例下面的 innerText 让 span 没有了，所以赋值要谨慎</p>
<p>innerHTML   ==&gt;    可取，可写，可赋值<br>innerText    ==&gt;    可取，可赋值 (老版本火狐不兼容) / textContent(火狐使用这个， 老版本 IE 不好使)<br>例 div.innerHTML 可以改变 div 里面的 HTML 的内容</p>
<p>2、Element 节点的一些方法ele.setAttribute()    //设置ele.getAttribute();    //取这个值行间属性可以设置系统没有的例</p>
<p>div.innerHTML = “123”;是覆盖</p>
<p>用.setAttribute()设置属性</p>
<p>用.getAttribute()取这个值</p>
<p>例通过 div.setAttribute(‘id’,’only’)动态的去改 div 的值</p>
<p>可赋值，可写值的才能+=<br>下面是用 innerHTML 改变css 行间样式</p>
<p>当满足一定条件时，if 就可以动态操作了，配合事件连成整体操作<br>这个行间属性可以设置系统没有的。data-log 是打点，点击率，这是人工设置的行间属性，不是系统定义的</p>
<p>例 innerText 可取可赋值<br>赋值会覆盖掉（能覆盖标签）</p>
<p>例如何取这个 data-log？</p>
<p>例给三个标签，让他们行间有一个属性 this-name，比如第一个 DIV，第二个SPAN</p>
<p>low 方法 div.innerHTML,剩下全手写</p>
<p>如果想改变一个div 结构或 dom 结构或 html 结构的 class，直接用 div.className=””就可以了，不用setAttribute<br>作业<br>1.封装函数 insertAfter()；功能类似 insertBefore(); insertAfter 是系统没有提供的<br>提示:可忽略老版本浏览器，直接在Element.prototype 上编程</p>
<p>2.将目标节点内部的节点顺序，逆序。（标签逆序） eg:<div> <a></a> <em></em></div></p>
<div><em></em><a></a></div>
利用 appendChild 和剪切，第一次先操作倒数第二个，第二次操作倒数第三个，写个
for 循环
3.封装 remove(); 使得 child.remove()直接可以销毁自身

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/11/js-basics-10-dom/" data-id="cka55rb03000nuwu10ejm6ui2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-9-es5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-9-es5/" class="article-date">
  <time datetime="2020-03-10T15:53:33.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-9-es5/">js-basics-9-es5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>es5.0 严格模式</p>
<p>（这章就是讲 es3.0 和 es5.0 产生冲突的部分） 浏览器是基于 es3.0 和 es5.0 的新增方法使用的。如果两种发生了冲突，就用 es3.0。<br>es5.0 严格模式是指 es3.0 和 es5.0 产生冲突发部分就是用 es5.0，否则就用es3.0。es5.0 严格模式的启动“use strict” ;<br>用法在写“use strict”，可以写在全局的最顶端，也可以写在某函数（局部）的最顶端，推荐使用局部的。</p>
<p>在 es5.0 不能用 argument.callee，但是 es3.0 可以用例 function test( ){ }里面加“use strict” ;是局部启动严格模式<br>全局严格模式<br>局部函数内严格模式（推荐）<br>就是一行字符串，不会对不兼容严格模式的浏览器产生影响。<br>不支持with，arguments.callee，function.caller，变量赋值前必须声明，局部 this<br>必须被赋值(Person.call(null/undefined) 赋值什么就是什么),拒绝重复属性和参数<br>例<br>浏览器升级到 es5.0 才好用写 strict( );就有风险<br>写成“use strict” ;有一个向后兼容的作用<br>例 es5.0 严格模式不让使用 with。with 可以改变作用域链<br>with（）括号里面的代码会按照正常顺序执行，但是如果在括号里面添加了对象，就会把对象当做 with 要执行的代码体的作用域链的最顶端（最直接的最近的 AO）。</p>
<p>下面这个 with 看到的就是 var obj 的 name （with 改变作用域链）</p>
<p>例命名空间应该像下面这样用的，with 可以简化代码<br>这也是 with 的运用方式<br>用 with 表示 document.write<br>with 过于强大，可以改作用域链，失去效率，所以 es5.0 不能用<br>rguments.callee 在 es5.0 严格模式下报错</p>
<p>es5.0 严格模式中：变量赋值前必须声明，局部 this 必须被赋值(Person.call(null/undefined) 赋值什么就是什么),拒绝重复属性和参数（this 不在指向window）</p>
<p>例局部 this 必须被赋值(Person.call(null/undefined) 赋值什么就是什么)</p>
<p>该对象的 constructor 是 Test，</p>
<p>全局的 this 指向 window</p>
<p>例拒绝重复属性和参数（this 不在指向window）</p>
<p>eval 很强大，能把字符串当成代码来执行<br>但是约定俗成在es3.0 中都不能使用 eval。eval 是魔鬼，因为会改变作用域</p>
<p>如果改变 global，他改变的是全局的<br>当情况不同，eval 改变的作用域是不同的<br>eval 还有自己独立的作用域<br>理解：可以把回调函数理解为先定义好了函数，执行的时候再回头调用<br>dom 这章之前是笔试面试的重点</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-9-es5/" data-id="cka55raza000huwu1cexlck0d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-8-try-catch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-8-try-catch/" class="article-date">
  <time datetime="2020-03-10T15:49:28.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-8-try-catch/">js-basics-8-try-catch</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> try…catch</p>
<p>防止我们报错</p>
<p>try 花括号{里面会正常执行，但是遇到 b 报错时 b 就执行不出来，后面的代码 c 就不<br> 执行了，但是外面的代码d 还能执行}catch(e)，这个 e 可以随便写，写 abc 都可以， 也是个形参</p>
<p>在 try 里面的发生错误，不会执行错误后的 try 里面的代码<br>catch</p>
<p> 如果 try 里面的代码不出错，在catch 里面的代码就不执行；<br> 如果 try 里面的代码出错，catch 负责补抓到错误信息封装到里面（error.massage     error.name），错误对象只有message 和 name。</p>
<p>try{}catch(e) {}finally{}</p>
<p>例在 es5.0 不能用 argument.callee，但是 es3.0 可以用</p>
<p>例 function test( ){ }里面加“use strict” ;是局部启动严格模式</p>
<p>Error.name 的六种值对应的信息：<br>（前面是错误名称，后面是错误信息）<br>1.EvalError：eval()的使用与定义不一致<br>//eval 是不被允许使用的<br>2.RangeError：数值越界<br>3.ReferenceError：非法或不能识别的引用数值<br>//未经声明就使用，没有定义就使用<br>4.SyntaxError：发生语法解析错误<br>// Syntax 是语法解析（）<br>5.TypeError：操作数类型错误<br>6.URIError：URI 处理函数使用不当<br>//引用地址错误<br>大部分都是 3 和 4 这种错误<br>伪代码也可以写了，可以写 var  老邓 = 123；这就是伪代码<br>var str = avs    ==&gt;    ReferenceError</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-8-try-catch/" data-id="cka55razb000iuwu1aaj15csd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-7-array" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-7-array/" class="article-date">
  <time datetime="2020-03-10T15:40:36.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-7-array/">js-basics-7-array</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数组</p>
<p>重点：数组常用方法，系统内部负数兼容问题，类数组，数组去重问题</p>
<p>一、数组的定义(来源于Array.prototype)<br>1）new Array(length/content);    var arr = new Array(1,2,3,4,5 ); 2）字面量    var arr = [1,2,3,4,5];<br>二、数组的读和写<br>arr [ num ]        //不可以溢出读，结果 undefined arr[num] = XXX;    //不可以溢出读<br>arr[num] = xxx;    //可以溢出写<br>es3.0 最标准最基础    es5.0    es6.0，最新的 es7.0 还没有普及，今天讲的都是 es3.0<br>对象的定义方式 1 字面量.2 构造函数,3 自定义构造函数 4object.create<br>数组是一种特殊的对象，在本质上两者没有太大的区别<br>例可以写 var arr = [,]    //稀松数组，相当于定了两个位置，conlogo 结果是undefined</p>
<p> 封装 type 方法<br>定义对象方式：自变量，构造函数，自定义的构造函数，Object.create<br>定义数组的方式：var arr = [ ] ;数组自变量；var arr = new Array ( ) ;系统提供。两者区别就只一位数的情况<br>数组能用的方法来源于Array.prototype<br>例 var arr = [ ] ;<br>如果写 var arr = [ 1, ,1]，出来就是 1，undefined*1，1<br>数组不是每一位都有值，稀疏数组例 var arr = new Array ( ) ;<br>var arr = new Array(1,2,3,4,5);跟上面效果一样</p>
<p>例 var arr = [ ];和 var arr = new Array( );唯一的区别是在 var arr = new Array( );只传了一个参数的情况下，会被当成长度，并且成为一个稀松数组</p>
<p>如传进去的参数是一个小数，就非法例</p>
<p>数组常用的方法一、改变原数组（在原来数组基础上去改变） 1）reverse,sort,push,pop, unshift, shift,<br>2）splice</p>
<p>例 unshift 是从第一位加东西</p>
<p>forEach filter map reduce reduceRight slice concat,join—&gt;split,toString<br>在控制台操作<br>例 push 是在数组的最后一位添加数据，可以添加一个，也可以添加很多个</p>
<p>例说明能重写</p>
<p>例数组有三位，想在数组最后一位添加东西<br>var arr = [ 1, 2, 3 ];如果在第四位加东西写成arr = [3]。    //length-1 位添加东西<br>例</p>
<p>Array . prototype.push = function ( ){    //不能写形参<br>例 pop 是剪切方法（把最后一位数剪切出去）。在 pop( )括号里面不能传参，写了会忽略</p>
<p>例数组不能从-1 位插入东西</p>
<p>可以用两个数组拼接成一个数组的方式添加东西例 reverse 逆反</p>
<p>例 splice 一种剪切，切片<br>// 这是从第零位到第五位<br>/arr.splice(从第几位开始，截取多少长度，传参在切口处添加新的数据)<br>arr.splice(1,2);    //从第 1 位开始截取 2 位，传参可以不填<br>截取的是[1,2]</p>
<p>例 arr.splice(1,1,0,0,0);<br>//意思是从第 1 位起截取 1 位，然后加上 0,0,0 这三个数<br>例 var arr = [1,2,3,5];    //1 是第 0 位，2 是第一位，3 是第二位，5 是第三位<br>arr.splice(3,0,4);<br>变成 arr    ==&gt;    1,2,3,4,5<br>例 var arr = [ 1,2,3,4 ];<br>arr.splice(-1,1);<br>//这里的-1 是倒数第一位<br>数组一般的方法都可以带负数</p>
<p>例下面是系统内部解决负数的问题的兼容</p>
<p>思维方式：上面就控制了升序<br>这个函数第一次调动时，会把数组的第一位和第二位传进来，也就是a=1，b=3，然后通过规则比较，当你把返回值返回为正，为负，为 0。<br>传参的顺序（但是这个顺序是位子的顺序，不是按数字比），第一次是 1,3，第二次 1,5,第三次 1,4,第四次 1,10，第五次 3,5,第六次 3,4,第七次 3,10，第八次 5,4，第九次<br>5,10，第十次 4,10；依次传参（符合冒号排序的算法） 是以换位置的方式改变顺序<br>例 var arr = [ 2,13,19,4];<br>//到 13 这一位时，换位置变成了[ 2,4,19,13]<br>例下面这种方式变成了降序</p>
<p>例 sort 给数组排序（按照从小到大），改变原数组</p>
<p>在 sort 后面加 reverse 就是降序例下面这个是按 asc 码排序的</p>
<p>所以给我们留了个接口，如下图<br>sort<br>1 必须写两形参 2 看返回值 return<br>1）当返回值为负数时，那么前面的数放在前面，<br>2）当返回值为正数时，那么后面的数在前，<br>3）为 0，不动<br>右边的<br>return 1;    //此处的 1 代表返回正的<br>return -1;    //此处的-1 代表返回负的</p>
<p>记住升序 return a –  b ;    降 序 return b – a ;<br>直接调用 arr.sort( )比的是 asc 码，要在里面填函数才可以</p>
<p>例给一个有序的数组，乱序。当我们没规律可以遵循的时候，返回的是随机的</p>
<p>// Math.random() 会生成一个 0 到 1（包括 0，但是不包括 1）的随机数<br>例给他们三个按照年龄升序</p>
<p>可以把右上改成简化版</p>
<p>例按字符串长度排序</p>
<p>例按字节长度排序</p>
<p>下面略微修改一下    </p>
<p>例 concat 连接， 把后面的数组拼到前面，并成立一个新的数组，不影响之前的两个数组。不能改变原数组</p>
<p>例 toString 是把数组当做字符串展示出来</p>
<p>例 slice 从该位开始截取，截取到该位，并不改变原数组，这里也可以写负数</p>
<p>把下面字符串拼到一起下，字符串是在栈内存里面的，先进后出</p>
<p>用下面这种方式更好，join 里面不传参默认用逗号连接，传空串</p>
<p>slice 并不改变原数组 slice 完了以后需要有东西接收，不然没有意义</p>
<p>1、可以利用属性名模拟数组的特性2、可以动态的增长length 属性</p>
<p>类数组</p>
<p>slice 里面可以填 0 个参数，也可以填 1 个参数，也可以填两个参数<br>1、如果填两个参数，slice（从该位开始截取，截取到该位） 如 arr.slice(1,2)从第一位开始截取，截取到第二位<br>2、如果填一个参数，从第几位开始截取，一直截取到最后。如果 arr.slice(1) ，从第 1 位开始截取，截取到最后一位<br>3、不写参数就是整个截取数组（把类数组转换成数组的时候经常使用到）<br>例  join 括号里面需要用字符串形式（标准语法规定），就会用加的东西连接起数组</p>
<p>例 join 可逆的东西：split( )是 string 字符串方法</p>
<p>split 按照什么拆分为数组。用什么拆，什么就没了，按-拆就去掉-，按 4 拆就去掉 4。<br>split 可以返回数组，数组可以返回字符串</p>
<p>3、如果强行让类数组调用push 方法，则会根据 length 属性值的位置进行属性的扩充。<br>例这个看着像数组，但是数组有的方法，他全部都没有，所以他是类数组</p>
<p>类数组长得像数组，但是没有数组所拥有的的方法。例</p>
<p>例下面是类数组的基本形态</p>
<p>关键点在 length 上面，根据 length 改变而改变，走一下length，即： Array.prototype.push = function (target){<br>this[obj.length] = target; this.length ++;<br>}</p>
<p>在控制台 push(‘d’)以后，obj 的object 多了一个 3：d，长度也变成了 4<br> 类数组    。<br>例：如果给一个对象加上 splice 方法，那么这个对象就长得像数组了。但他仍然<br> 象，但是可以当做数组来用，需要自己添方法。（如下图）</p>
<p>如果对象 obj 调用这个方法，那么this 变成了obj</p>
<p>答案：“1”：“a”，“2”：“c”，“3”：“b”，“length”：4</p>
<p>作业 1、封装 type 方法</p>
<p>作业答案：<br>1、封装 type（这个方法是一个工具类方法，可以存在库里面），区分 typeof 方法<br>1）先分类，原始值，引用值<br>2）区分引用值，先判断是不是 null<br>数组，对象，包装类(new number )会返回object，通过 Object.prototype.toString</p>
<p>简化写法–进一步简化</p>
<p>2、数组去重（利用对象的特性做数组去重，去重就是去掉重复）<br>思路：写一个对象，把数组的每一位当做对象的属性名。利用对象的特性（同一属性名不可以出现两次），先把第一位当做属性名添加进去，属性值随便写个，再看第二位，如果第二位在对象里面有属性名，就看下一位，如果对象里面没有属性名， 就把这个值添加进去当属性名。只看对象的属性名，就去重了，这个方法叫hash。</p>
<p>每一圈循环都要this.length; 写成 var len = this.length;这样直接放值能少一些运算。[this[i]]代表数组的第几位。“abc”可以随便填值（要求是字符串，但是不为 false），但是填[this[i]]= [this[i]];在数组有 0 的时候就会有 bug。<br>if 里面取到值什么都不敢，取到 undefined 才开始操作，所以写非！，没有值，才处理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-7-array/" data-id="cka55rb06000quwu1fezg0as4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/blog/">&amp;laquo; Prev</a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2020/05/13/C-number01-part08/">C-number01-part08</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/13/C-number01-part07/">C-number01-part07</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/13/C-number01-part06/">C-number01-part06</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/13/C-number01-part05/">C-number01-part05</a>
          </li>
        
          <li>
            <a href="/blog/2020/05/13/C-number01-part04/">C-number01-part04</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>
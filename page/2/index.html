<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-js-basics-7-array" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-7-array/" class="article-date">
  <time datetime="2020-03-10T15:40:36.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-7-array/">js-basics-7-array</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数组</p>
<p>重点：数组常用方法，系统内部负数兼容问题，类数组，数组去重问题</p>
<p>一、数组的定义(来源于Array.prototype)<br>1）new Array(length/content);    var arr = new Array(1,2,3,4,5 ); 2）字面量    var arr = [1,2,3,4,5];<br>二、数组的读和写<br>arr [ num ]        //不可以溢出读，结果 undefined arr[num] = XXX;    //不可以溢出读<br>arr[num] = xxx;    //可以溢出写<br>es3.0 最标准最基础    es5.0    es6.0，最新的 es7.0 还没有普及，今天讲的都是 es3.0<br>对象的定义方式 1 字面量.2 构造函数,3 自定义构造函数 4object.create<br>数组是一种特殊的对象，在本质上两者没有太大的区别<br>例可以写 var arr = [,]    //稀松数组，相当于定了两个位置，conlogo 结果是undefined</p>
<p> 封装 type 方法<br>定义对象方式：自变量，构造函数，自定义的构造函数，Object.create<br>定义数组的方式：var arr = [ ] ;数组自变量；var arr = new Array ( ) ;系统提供。两者区别就只一位数的情况<br>数组能用的方法来源于Array.prototype<br>例 var arr = [ ] ;<br>如果写 var arr = [ 1, ,1]，出来就是 1，undefined*1，1<br>数组不是每一位都有值，稀疏数组例 var arr = new Array ( ) ;<br>var arr = new Array(1,2,3,4,5);跟上面效果一样</p>
<p>例 var arr = [ ];和 var arr = new Array( );唯一的区别是在 var arr = new Array( );只传了一个参数的情况下，会被当成长度，并且成为一个稀松数组</p>
<p>如传进去的参数是一个小数，就非法例</p>
<p>数组常用的方法一、改变原数组（在原来数组基础上去改变） 1）reverse,sort,push,pop, unshift, shift,<br>2）splice</p>
<p>例 unshift 是从第一位加东西</p>
<p>forEach filter map reduce reduceRight slice concat,join—&gt;split,toString<br>在控制台操作<br>例 push 是在数组的最后一位添加数据，可以添加一个，也可以添加很多个</p>
<p>例说明能重写</p>
<p>例数组有三位，想在数组最后一位添加东西<br>var arr = [ 1, 2, 3 ];如果在第四位加东西写成arr = [3]。    //length-1 位添加东西<br>例</p>
<p>Array . prototype.push = function ( ){    //不能写形参<br>例 pop 是剪切方法（把最后一位数剪切出去）。在 pop( )括号里面不能传参，写了会忽略</p>
<p>例数组不能从-1 位插入东西</p>
<p>可以用两个数组拼接成一个数组的方式添加东西例 reverse 逆反</p>
<p>例 splice 一种剪切，切片<br>// 这是从第零位到第五位<br>/arr.splice(从第几位开始，截取多少长度，传参在切口处添加新的数据)<br>arr.splice(1,2);    //从第 1 位开始截取 2 位，传参可以不填<br>截取的是[1,2]</p>
<p>例 arr.splice(1,1,0,0,0);<br>//意思是从第 1 位起截取 1 位，然后加上 0,0,0 这三个数<br>例 var arr = [1,2,3,5];    //1 是第 0 位，2 是第一位，3 是第二位，5 是第三位<br>arr.splice(3,0,4);<br>变成 arr    ==&gt;    1,2,3,4,5<br>例 var arr = [ 1,2,3,4 ];<br>arr.splice(-1,1);<br>//这里的-1 是倒数第一位<br>数组一般的方法都可以带负数</p>
<p>例下面是系统内部解决负数的问题的兼容</p>
<p>思维方式：上面就控制了升序<br>这个函数第一次调动时，会把数组的第一位和第二位传进来，也就是a=1，b=3，然后通过规则比较，当你把返回值返回为正，为负，为 0。<br>传参的顺序（但是这个顺序是位子的顺序，不是按数字比），第一次是 1,3，第二次 1,5,第三次 1,4,第四次 1,10，第五次 3,5,第六次 3,4,第七次 3,10，第八次 5,4，第九次<br>5,10，第十次 4,10；依次传参（符合冒号排序的算法） 是以换位置的方式改变顺序<br>例 var arr = [ 2,13,19,4];<br>//到 13 这一位时，换位置变成了[ 2,4,19,13]<br>例下面这种方式变成了降序</p>
<p>例 sort 给数组排序（按照从小到大），改变原数组</p>
<p>在 sort 后面加 reverse 就是降序例下面这个是按 asc 码排序的</p>
<p>所以给我们留了个接口，如下图<br>sort<br>1 必须写两形参 2 看返回值 return<br>1）当返回值为负数时，那么前面的数放在前面，<br>2）当返回值为正数时，那么后面的数在前，<br>3）为 0，不动<br>右边的<br>return 1;    //此处的 1 代表返回正的<br>return -1;    //此处的-1 代表返回负的</p>
<p>记住升序 return a –  b ;    降 序 return b – a ;<br>直接调用 arr.sort( )比的是 asc 码，要在里面填函数才可以</p>
<p>例给一个有序的数组，乱序。当我们没规律可以遵循的时候，返回的是随机的</p>
<p>// Math.random() 会生成一个 0 到 1（包括 0，但是不包括 1）的随机数<br>例给他们三个按照年龄升序</p>
<p>可以把右上改成简化版</p>
<p>例按字符串长度排序</p>
<p>例按字节长度排序</p>
<p>下面略微修改一下    </p>
<p>例 concat 连接， 把后面的数组拼到前面，并成立一个新的数组，不影响之前的两个数组。不能改变原数组</p>
<p>例 toString 是把数组当做字符串展示出来</p>
<p>例 slice 从该位开始截取，截取到该位，并不改变原数组，这里也可以写负数</p>
<p>把下面字符串拼到一起下，字符串是在栈内存里面的，先进后出</p>
<p>用下面这种方式更好，join 里面不传参默认用逗号连接，传空串</p>
<p>slice 并不改变原数组 slice 完了以后需要有东西接收，不然没有意义</p>
<p>1、可以利用属性名模拟数组的特性2、可以动态的增长length 属性</p>
<p>类数组</p>
<p>slice 里面可以填 0 个参数，也可以填 1 个参数，也可以填两个参数<br>1、如果填两个参数，slice（从该位开始截取，截取到该位） 如 arr.slice(1,2)从第一位开始截取，截取到第二位<br>2、如果填一个参数，从第几位开始截取，一直截取到最后。如果 arr.slice(1) ，从第 1 位开始截取，截取到最后一位<br>3、不写参数就是整个截取数组（把类数组转换成数组的时候经常使用到）<br>例  join 括号里面需要用字符串形式（标准语法规定），就会用加的东西连接起数组</p>
<p>例 join 可逆的东西：split( )是 string 字符串方法</p>
<p>split 按照什么拆分为数组。用什么拆，什么就没了，按-拆就去掉-，按 4 拆就去掉 4。<br>split 可以返回数组，数组可以返回字符串</p>
<p>3、如果强行让类数组调用push 方法，则会根据 length 属性值的位置进行属性的扩充。<br>例这个看着像数组，但是数组有的方法，他全部都没有，所以他是类数组</p>
<p>类数组长得像数组，但是没有数组所拥有的的方法。例</p>
<p>例下面是类数组的基本形态</p>
<p>关键点在 length 上面，根据 length 改变而改变，走一下length，即： Array.prototype.push = function (target){<br>this[obj.length] = target; this.length ++;<br>}</p>
<p>在控制台 push(‘d’)以后，obj 的object 多了一个 3：d，长度也变成了 4<br> 类数组    。<br>例：如果给一个对象加上 splice 方法，那么这个对象就长得像数组了。但他仍然<br> 象，但是可以当做数组来用，需要自己添方法。（如下图）</p>
<p>如果对象 obj 调用这个方法，那么this 变成了obj</p>
<p>答案：“1”：“a”，“2”：“c”，“3”：“b”，“length”：4</p>
<p>作业 1、封装 type 方法</p>
<p>作业答案：<br>1、封装 type（这个方法是一个工具类方法，可以存在库里面），区分 typeof 方法<br>1）先分类，原始值，引用值<br>2）区分引用值，先判断是不是 null<br>数组，对象，包装类(new number )会返回object，通过 Object.prototype.toString</p>
<p>简化写法–进一步简化</p>
<p>2、数组去重（利用对象的特性做数组去重，去重就是去掉重复）<br>思路：写一个对象，把数组的每一位当做对象的属性名。利用对象的特性（同一属性名不可以出现两次），先把第一位当做属性名添加进去，属性值随便写个，再看第二位，如果第二位在对象里面有属性名，就看下一位，如果对象里面没有属性名， 就把这个值添加进去当属性名。只看对象的属性名，就去重了，这个方法叫hash。</p>
<p>每一圈循环都要this.length; 写成 var len = this.length;这样直接放值能少一些运算。[this[i]]代表数组的第几位。“abc”可以随便填值（要求是字符串，但是不为 false），但是填[this[i]]= [this[i]];在数组有 0 的时候就会有 bug。<br>if 里面取到值什么都不敢，取到 undefined 才开始操作，所以写非！，没有值，才处理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-7-array/" data-id="ck7xh5r39000fcku1eehaf845" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-6-this" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-6-this/" class="article-date">
  <time datetime="2020-03-10T15:33:04.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-6-this/">js-basics-6-this</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>this<br>重点：this预编译过程，arguments,克隆(深层克隆，浅层克隆)，</p>
<p>this —&gt; 指 向 window</p>
<p>可以改变函数运行时this 指向<br>func()里面的 this 指向 obj<br>谁调用这个方法,这个方法里的 this 就是指向谁    →</p>
<p>例<br>a.say 是 function 函数体<br>function (fun){<br>//this → b<br>//console.log(this)→b<br>fun( );</p>
<p>}<br>fun()空执行，走预编译<br>在 b.say(a.say)中<br>a.say 当做参数传进来了</p>
<p>答案 fun( )是 222    a.say 是 111    b.say(a.say);是 222    b.say( );是 333</p>
<p>arguments arguments.callee 指向函数的引用（函数自己） function.caller</p>
<p>例我们要初始化数据，是 100 以内的阶乘，用立即执行函数找到自己的引用来解决</p>
<p>在哪个函数里面的 arguments.callee 就指代了哪个函数</p>
<p>例 caller 谁叫他，caller 不能用在 arguments 里面</p>
<p>demo 被调用的环境是 test 所以这个 caller 指代的 test 例</p>
<p>答案是 456<br>把上面这题变形：</p>
<p>答案打印 234，要 console.log(foo);是全局的 foo，但是这里 this.foo 的 this 是指向全局 window 的，相当于就把外面的 123 改成了 234<br>例</p>
<p>答案 123，new 了以后，隐式 var this = Object.create(print.prototype)这时候 this.foo 不<br>再指向 window，转而指向var this，所以打印的时候找不到 234，就到全局找到 123</p>
<p>答案运行 test( )是 0，5，0【之前其中 this.a 指代的是 window，所以是 5】运行 new test( )是 0，undefined ，0【因为 this 上没有 a，所以打印 undefined<br>在执行 test( )之前，AO 被定义{a:undefined}，执行之后，AO 被执行{a:0,this:window} 在执行new test( )时会隐式的var this = Object.create(test.prototype)简化就是var this ={<br>    proto : test prototype}一个对象上面没有的属性，打印出来就是 undefined new test( );执行的时候 AO 是{a:0，this:{} }</p>
<p>答案 undefined，2，报错 hello is no defined<br>因为 hello 没有被定义，所以报错例</p>
<p>答案打印 One！ 例</p>
<p>答案：test1，test2，marty，做不了有 bind，test3<br>例</p>
<p>bar.a=’a’;<br>把{a:”002”}<br>变成<br>{a:’a’}<br>答案 a，b 其中 print( ) ( )第一个括号返回的是一个函数，第二个再来函数执行</p>
<p>思考上一个题做深度克隆，分析他是什么，建立是什么，收尾需要一个递归，提示：</p>
<p>作业：做一个深度克隆（copy 后，各自独立，互不影响）<br>思路：需要一个分析环节，分析是什么，是原始值就按原来的方法拷贝过来，是引用值就分析是数组还是对象。如果是数组，就新建一个数组；如果是对象，就新建一个对象。再一层层看，里面有一个递归。引用值不能直接拷贝，引用值拷贝的是地址</p>
<p>var obj = {<br>name : “abc”, age : 123,<br>card : [‘visa’, ‘master’], //原始对象<br>wife : {<br>name : “bcd”, son : {<br>name : “aaa”<br>}</p>
<p>deepClone ( origin [ prop ], target [ prop ]);<br>}else{    //else 后面是原始值<br>target [ prop ] = origin [ prop ];<br>}<br>}<br>}<br>return target;<br>}</p>
<p>}<br>var obj1 = {<br>name : “abc”, age : 123,<br>card : [ obj.card[ 0 ],obj.card[ 1 ] ],<br>//要拷贝的对象，进行 obj 里面的数组，对这个数组的拷贝再一次拷贝<br>wife : {<br>name : “bcd”, son : {<br>name : “aaa”<br>}<br>}<br>}<br>function deepClone(origin, target){<br>var target = target | | {},    //有就用你的，没有就用后面的<br>toStr = Object.prototype.toString,    //引用，目的是简化<br>arrStr =  “ [ Object Array ]  ”;    //引用，目的是简化比对<br>for ( var prop in origin ) {    //从原始 origin 拷贝到 target<br>if( origin . hasOwnProperty( prop ) ){    //先判断是不是原型上的属性，如果是false 就是原型上的<br>if( typeof (origin [ prop ] ) !== “null” &amp;&amp; typeof ( origin [ prop ] ) ==<br>‘object’) {<br>if ( toStr.call( origin    [ prop ] ) ) == arrStr ){ target [ prop ] = [ ];<br>}else{<br>target [ prop ] = { };<br>}</p>
<p>深度克隆的步骤<br>1、先把所有的值都遍历一遍（看是引用值和原始值）<br>用 for ( var prop in obj )，对象和数组都可以使用<br>2、判断是原始值，还是引用值？用 typeof 判断是不是object 1）如果是原始值就直接拷贝<br>2）如果是引用值，判断是数组还是对象<br>3、判断是数组还是对象？（方法instanceof【看a 的原型链上有没有b 的原型】、toString、constructor，建议用 toString,另外两个有个小bug——跨父子域不行） 1）如果是数组，就新建一个空数组；<br>2）如果是对象，就新建一个空对象。<br>4、建立了数组以后，如果是挨个看原始对象里面是什么，都是原始值就可以直接考过来了；或者，建立了对象以后，挨个判断对象里面的每一个值，看是原始值还是引用值<br>5、递归<br> 三目运算符    ?    :<br> 形式：?问号前面是一个条件判断，判断 true 就走：冒号前面的；false 就走：冒号后<br> 面的，并且会返回值    条件判断？    是 ： 否    并且会返回值三目运算符是简化版的 if（条件判断）{是在这里}else{否在这里}<br>例 var num = 1 &gt; 0 ? 2 + 2 : 1 + 1;<br>//答返回值为 4<br>例 var num = 1 &lt; 0 ? 2 + 2 : 1 + 1;<br>//答返回值为 2<br>例 ar num = 1 &gt; 0 ? ( “10” &gt; 9 ? 1 : 0 ) : 2;<br>//答 1<br>例 var num = 1 &gt; 0 ? ( “10” &gt; “ 9 “ ? 1 : 0 ) : 2;<br>//答 0，因为“10” &gt; “ 9 “ 比的是ASCII 码，一位位比，一零小于 9，先用 1 和<br>9 比，在 asc 妈里面 1 小于 9；<br>当“10” &gt;    9 字符串和数字比，会先转换成数字再比较</p>
<p>例可利用三目运算符简化克隆的代码<br>for ( var prop in origin ) {<br>if( origin . hasOwnProperty( prop ) ){<br>if( typeof (origin [ prop ] ) !== “null” &amp;&amp; typeof ( origin [ prop ] ) ==<br>‘object’) {<br>target [ prop ] = toStr.call (origin [ prop ] ) ==arrStr ? [] : {}; deepClone ( origin [ prop ], target [ prop ]);<br>}else{    //else 后面是原始值<br>target [ prop ] = origin [ prop ];</p>
<p>例 var arr = new Array ( 10 );长度为 10 的稀疏数组，括号里面只有一位数，就代表着长度，并且里面每一位都没有值，console 里面会是undefined*10。并且里面不能写小数，会报错。<br>var arr1 = [ 10 ]；<br>数组的读和写，基本上没有报错的情况，除非是引用了没有的方法<br>js 数组是基于对象的，数组是一种特殊的对象</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-6-this/" data-id="ck7xh5r210006cku1fak82yfu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-5-inherit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-5-inherit/" class="article-date">
  <time datetime="2020-03-10T15:26:38.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-5-inherit/">js-basics-5-inherit</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>继承</p>
<p>重点：call/apply方法，共享原型，圣杯模式，命名空间优化，对象枚举 </p>
<p>作用，改变 this 指向。<br>区别，后面传的参数形式不同。<br>toFixed 是保留两位有效数字<br>例有个 bug，在控制台 0.14*100<br>出现 14.0000000000002，是 js 开发精度不准例向上取整 Math.ceil(123.234)<br>答案 124<br>例向下取整 Math.floor(123.999)<br>答案 123<br>例 Math.random()是产生一个 0 到 1 区间的开区间 随机数例</p>
<p>所以一般在这种情况下，我们不用 toFixed，因为精度不准确</p>
<p>例用这种方法取整更好，就不会精度不准确</p>
<p>例</p>
<p>注意：之前 js 在小数点后面最多能容纳 15-17 位，但是升级后能用科学计数法表示如 2e-17（是 2 乘以 10 的负 17 次方）<br>而小数点前面只能容纳 16 位的运算， 可正常计算的范围是小数点前后 16 位<br>例    任何一个方法都可以.call<br>.call 才是一个方法执行的真实面目</p>
<p>直接执行Person.call ( )和Person ( )没有区别Person.call( );括号里面可以传东西<br> 如果Person.call( obj );里面的 call 让 person 所有的 this 都变成 obj<br>不 new 的话，this 默认指向 window。call 的使用必须要new<br>call 的第一位参数用于改变this 指向，第二位实参（对应第一个形参）及以后的参数<br> 都当做正常的实参，传到形参里面去<br> 借用别人的方法，实现自己的功能。<br>例写 test（）和写 test.call（）是一样的，→<br>例<br>如右图<br>两个人的需求有重复部分</p>
<p>call 改变 this 指向，借用别人的函数，实现自己的功能。只能在你的需求完全涵盖别人的时候才能使用<br>如果不想要 age 这个，就不能使用这种方法</p>
<p>继承发展史<br>//问题：过多的继承了没用的属性</p>
<p>Person.call(this, name, age, sex);里面的 this 现在是 new 了以后的 var this={}<br>利用Person 方法，实现了Student 自己的封装例 function Wheel ( wheelSize,</p>
<p>不能继承借用构造函数的原型 每次构造函数都要多走一个函数</p>
<p>所以不算标准的继承模式<br>==&gt;浪费效率</p>
<p>this 放进去的前提，这个函数必须是 new 来的</p>
<p>apply 也是改变 this 指向的，只是传参列表不同，第一位也是改变 this 指向的人，第<br> 二位，apply 只能传一个实参，而且必须传数组 argunments call 需要把实参按照形参的个数传进去</p>
<p>4.圣杯模式<br>圣杯模式是在方法三的共有原型，但是在共有原型的基础上有改变。共享原型是：son.prototype=father.prototype</p>
<p>例：左下这种方法就不好使了，相当于右下。还是原型指向有问题，new 的时候用的是原来的原型，再 F.prototype =father.prototype 没用，son.prototype 没发生改变</p>
<p>例，在雅虎时代，封装了 YUI3 库来解决方法三的不足，与圣杯模式相似。现在不用<br>YUI3 库，现在用 jq</p>
<p>联系到闭包作用：可以实现封装，属性私有化。<br>例为什么在外部执行的divorce 能用内部的变量？能换成 xiaozhang？<br>因为 this.divorce 在对象上，由于对象被返回了，这个方法也被返回了。<br>因为闭包。这个函数被储存到了外部，所以储存了这个函数的执行期上下文。所以可以用这个闭包。所以var prepareWife 被下面的 this=fn 三个函数共用，这三个函数分别与 fn Deng 形成了闭包，共同用 Deng 的AO,所以可以在外部随意存取。</p>
<p>deng.prepareWife 是 undefined 的，表面上看起来不是自己的，但是实际上只有对象<br> 自己通过对象自己设置的方法可以去操作他。外部用户通过对象. prepareWife 是看不<br> 到的。只有自己能看到，就是闭包的私有化的运用。</p>
<p>上面的 var inherit 与右边 的 var inherit 是一样的意思建议写上面的这种</p>
<p>上面的 var F 这个 F 形成了闭包，成为了这个函数的私有化变量，而且变成私有化变量就更好</p>
<p>多人开发，对象命名容易重复，就要解决命名空间的问题<br>右边是命名空间老旧的解决方    ==&gt;<br>用的时候，用下面的写法</p>
<p>下面是现在公司最常见的方法：用闭包来解决（也可用 webpack），返回方法的调用。<br>init 是初始化，入口函数，入口名字。init 调用了这个函数的功能</p>
<p>obj.eat().smoke().drink().eat().sleep();</p>
<p>上面改成下面的写法：用 return this，就可以连续调用和执行了。deng.smoke().drink()</p>
<p>上面是用 return this 连续调用</p>
<p>obj.prop    查看就用.XXXX<br>例想要传序号几，就会调用几<br>老旧办法看右边，<br>然后 case1。。。 case2。。。连着往下写这种方法不好，下面的方法更好<br>var obj = { name : “abc” }<br>用方括号来访问属性也是一样的（里面必须是字符串）  这两种基本上完全相同 obj.name    →    obj [ ‘name’ ] 想实现属性名的拼接，只能用方括号的形式</p>
<p>for in 循环(简化版 for 循环)，目的是便利对象，通过对象属性的个数来控制循环圈数，这个对象有多少属性循环多少圈，而且在每一圈时，都把对象的属性名放到 Prop 里面 在枚举里面，一定要写成 obj[prop]不能加字符串<br>1.hasOwnProperty 2.in<br>3.instanceof<br>枚举也就是遍历：挨个知道信息的过程就叫这个数据组的遍历例</p>
<p>例</p>
<p>//上面就是 for in 循环，就是遍历用的。通过对象的属性个数来控制循环圈数，有多少个属性就会循环多少圈。<br>for（var prop in obj）在循环每一圈的时候，他会把对象的属性名放在 prop 里面。想遍历谁就 in 谁，prop 可以写别的，obj 就是我们想要遍历的对象。<br>var XX in XX 的格式是固定的。<br>var 也可以写在外面，写成var key； for（key in obj1）效果是一样的</p>
<p>写成下面这样会出错</p>
<p>上面 obj.prop 系统以后我们写的是 obj[‘prop’]，系统会以为我们是在让他访问 prop<br>这个属性，不会把prop 当成一个变量来使用。写成obj[prop]就可以成功访问了。</p>
<p>写对象时用方括号的形式不容易犯错例<br>右边写法会把原型上面的东西也拿出来</p>
<p>如果在遍历的时候，我们不想把原型上面的属性拿出来，可以用 hasOwnProperty，<br> 一般与 for in 循环成套出现<br>hasOwnProperty 是一个方法，来判断这个对象是你自己的还是原型的， 任何一个对象里面都有 hasOwnProperty，里面是需要传参的，把属性名传进去（如 prop）。下面达到了如果不是自己的属性，是原型上的属性，就不会返回。</p>
<p>注明：for in 循环理论上可以返回原型和原型链上的东西，一旦这个原型链延展到了的 object.prototype 上，不会打印系统的，只会打印自带的。<br>var obj = {<br>    proto     : {<br>lasrName：“deng“，<br>    proto     : Object . prototype    //不会打印这个object.prototype</p>
<p>in 操作符：很少用<br>in 操作符你的也是你的，你父亲的也是你的，只能判断这个对象能不能访问到这个属性，包括原型上；不是判断属性属不属于这个对象的</p>
<p>判断一个属性属不属于这个对象的只能用 hasOwnProperty<br>instanceof 操作用法类似于 in，但是完全不同<br>A instanceof B 的意思是 A 对象是不是 B 构造函数构造出来的；记住是：看A 对象的原型链上有没有B 的原型<br>解决了<br>例</p>
<p>判断这个变量是数组还是变量例</p>
<p>例区别传的变量是数组还是对象的方法：一是 constructor，二是 instanceof</p>
<p>例    加 Object . prototype.abc = ‘123’;    加个！变成只有不是他的才打印</p>
<p>第三种区分数组还是对象的方法：想让数组调用他的toString 方法<br>Object . prototype . toString . call ( [ ] ) ;    //[]会替换 this<br>Object . prototype . toString = function ( ) {<br>识别 this（谁调的他，这个this 就是谁） 返回相应的结果</p>
<p>}<br>obj . toString ( ) ;</p>
<p>例：下面这段 js 代码执行完毕后x，y，z 的值分别是多少？<br>var x = 1, y = z = 0; function add(n){<br>return n = n + 1;</p>
<p>进制<br>十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f<br>十六进制的中 10 是十进制的 16，    1f = 16 + 15<br>二进制中的 10 是十进制的 2，11 是十进制的 3</p>
<p>}<br>y = add(x); function add(n){<br>return n = n + 3;</p>
<p>}<br>z = add (x);<br>答案 1，4，4，同一个函数，后面会覆盖前面的，fn add 会提升到前面例：下面代码中 console.log 的结果是[1, 2, 3, 4, 5]的选项是：<br>A、function foo (x){<br>console.log(arguments) return x<br>}<br>foo(1, 2, 3, 4, 5)<br>B 、 function foo (x){ console.log(arguments)<br>return x<br>} (1, 2, 3, 4, 5)<br>C 、 ( function foo (x){ console.log(arguments)<br>return x<br>})(1, 2, 3, 4, 5)<br>D、function foo(){bar .apply (null, arguments);} function bar (x) {console.log(arguments);}<br>foo(1, 2, 3, 4, 5);<br>答案 A, C,D    其中b 执行不了,但是不报错<br>bar 里面传了一下参数。bar .apply (null, arguments);写成 bar (arguments);<br>例：一行文本，水平垂直居中<br>答案：height = line height    text-align:center<br>例：请问以下表达式的结果是什么？<br>parseInt(3, 8)        parseInt(3, 2)        parseInt(3, 0) A.3，3，3    B.3，3， NaN    C.3， NaN， NaN    D.other 答案 C 或D（有的浏览器 0 进制报错，有的不报错）</p>
<p>例：以下哪些是JavaScript 语言 typeof 可能返回的结果<br>A.string    B.array    C.object    D.null<br>例：JavaScript 的 call 和 apply 方法是做什么的，两者有什么区别？ 例：看看下面 alert 的结果是什么？<br>function b (x, y, a){ arguments [ 2 ] = 10; alert( a );<br>}<br>b(1, 2, 3);<br>如果函数体改成下面，结果又会是什么？<br>a = 10;<br>alert(arguments[2]);<br>答案两个都是 10<br>逗号操作符，这种情况，会看一眼 1，在看一眼 2，然后返回第二个，就是 2<br>例：</p>
<p>答案是 number</p>
<p>例    前面的 var this = Object.creat(test.prototype);是最标准的写法<br>new tes（t   ）；就会让 var this = Object.creat(test.prototype);如果不 new，this 指向 window</p>
<p>用括号把 function f （）{}转换成表达式，就被立即执行了，就找不到了。<br>因为 function f （）{}肯定是 true，所以会执行{}，但 typeof f 中的 f 已经找不到了<br>答案是 1undefined<br>下面是用友的题目<br>例：以下哪些表达式的结果为 true（    ）<br>A.undefined == null    B.undefined === null    C.isNaN(“100”)    D.parseInt(“la”) ==1<br>答案 A、C、D    //isNaN（”100”）意思是这个数经过 number 转换后是不是 NaN<br>C</p>
<p>parseInt（“1a”）==1。    引用值比的是地址</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-5-inherit/" data-id="ck7xh5r2s000dcku113mqgkoq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-4-object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-4-object/" class="article-date">
  <time datetime="2020-03-10T15:19:48.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-4-object/">js-basics-4-object</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对象<br>（构造函数 包装类 原型  原型链）</p>
<p>1.用已学的知识点，描述一下你心目中的对象。<br>例</p>
<p>灰色的 undefined 是返回值，因为没有设置返回值，所以就是灰色的undefined</p>
<pre><code>.代表函数引用    </code></pre><p>改mrDeng.health 为this.health，此处this 指代的是自己，是第一人称，指的就是mrDeng。因为 this 是在一个方法里面，所以指的这个方法。<br>smoke : function (){ console.log(‘I am good’) this.health –;<br>},<br>2.属性的增、删、改、查<br>例在上面的基础上 mrDeng.wife = “xiaoliu”<br>也可以在控制台操作<br>3.<br>对象的创建方法<br>(2)构造函数<br>1)系统自带的构造函数 Object()<br>     new Object();Array();Number();Boolean();Date();<br>系统自带的构造函数Object()可以批量生成对象，每一个对象都一样，但是彼此相互独立。<br>在 Object()前面加个 new，变成 new Object()的执行，就会真正的返回一个对象，通过 return 返回，拿变量接受。var obj = new Object();<br>var obj = new Object();和 var obj = {};这样写区别不大</p>
<p>例 var obj = new Object();    例<br>obj.name = ‘abc’; obj.sex = “male”;<br>双引号和单引号都是表示的字符串，写双引号也可以写单引号，但是为了跟后端 php<br>配合最好写单引号。如果要打印一个单个的引号，用正则表达式转义字符\  注意等号和冒号的用法 obj.say = function(){}    var obj = { name : ‘abc’} 2）自定义<br>Object.create(原型)方法<br>例 function Person(){}</p>
<p>构造函数内部原理</p>
<p>Person 是可以随便写的，也是构造函数构造函数跟函数结构上没有任何区别 例 var person1 = new person();<br>必须用 new 这个操作符，才能构造出对象<br>构造函数必须要按照大驼峰式命名规则，但凡是构造函数就要大写，例如TheFirNa<br>例</p>
<p>car1 和 car 是长得一样，但是是不同的两个 car。方法名和对象名尽量不一样a 和A 变量是两个变量，var car = new Car 里面 car 和 Car 是两个变量<br>例<br>这里的 color 可以和上面的重复</p>
<p>通过参数，<br>使函数发生变化，变成自定义</p>
<p>前提必须要加 new，以下三步都是隐式的：<br>1.在函数体最前面隐式的加上var this = {}    空对象<br>2.执 行 this.xxx = xxx;<br>3.隐式的返回 return this<br>例</p>
<p>例 function Person(name, height){<br>//隐式的 var this = {}，下面正常执行 this<br>this.name = name; this.height = height; this.say = funtion (){<br>console.log(this.say);<br>//此处的 this 和外面的 this 不同<br>}<br>// 隐式的 return this;<br>}<br>console.log(new Person(‘xiaowang’, 180).name);<br>例也可以这样显式的写出来<br>function Person (name, height){<br>var that = {};    //显式写出来that.name = name;<br>that.height = height;<br>return that;    //显式写出来</p>
<p>例</p>
<p>答案现在的 peson 和 person1 都是 Object{}<br>如果 return 写成 return 123，会使 return 失效，如右上图<br>x 有 new 了以后就不能返回原始值，例如 123</p>
<p>var num =123;    →    原始值数字<br>只有原始值数字是原始值，原始值不能有属性和方法<br>属性和方法只有对象有，包括对象自己，数组，function</p>
<p>var num = new number 123;    →    构造函数。是对象 123，不是原始值数字</p>
<p>字符串类型的对象<br>var num = new Nunber(123);    //数字类型对象var str = new String(‘abcd’);        //字符串类型对象var bol = new Boolean(‘true’);    //布尔类型对象</p>
<p>undefined 和null 不可以有属性<br>不能写成 undefined.abc = 123;会报错</p>
<p>例原始值不可能有属性和方法，但经过了包装类(加隐式)可以调用一些属性与方法<br>var num = 4；<br>num.len = 3;<br>//系统隐式的加上 new Number(4).len = 3;  然后 delete<br>console.log(num.len);<br>//系统隐式的加上 new Number(4).len; 但是这个new number 和上面的 new number<br>不是同一个，所以返回undefined 而上面这些隐式的过程就是包装类例 var str = “abcd”;<br>str.length = 2;<br>//隐式的加上 new string(‘abcd’).length = 2;    delete<br>console.log(str); console.log(str.length);<br>答案是 abcd，4<br>例</p>
<p>str += 1;    //abc1<br>var test = typeof(str);    //test ==  “string”，返回  string，string 长度是 6<br>if(test.length == 6){<br>test.sign =  “typeof 的返回结果可能为 String”;    //这是原始值,原始值要赋属性值需要调用包装类，赋了跟没赋值是一样的，new String(test).sign=’xxx’;<br>}<br>conlogo.log(test.sign);    //new String(test).sign<br>答案 undefined<br>例</p>
<p>答案 A，里面并没有用参数<br>被写死了，传参不成功</p>
<p>例    答案：A<br>例：看看下面 alert 的结果是什么？<br>function b (x, y, a) { arguments[ 2 ] = 10; alert( a );</p>
<p>答案 1，2，1<br>例</p>
<p>}<br>b(1, 2, 3);<br>如果函数体改成下面，结果又会是什么？<br>a = 10；<br>alert(arguments[ 2 ]);<br>答案 10，10</p>
<p>例下面代码中 console.log 的结果是[1,2,3,4,5]</p>
<p>答 案 1，4, 4 同一个函数，后面会覆盖前面的fn add 会提升到前面</p>
<p>答案 ACD（枚举后面有清晰版）<br>例：请问以下表达式的结果是什么？<br>parseInt(3, 8)<br>parseInt(3, 2)<br>parseInt(3, 0)<br>答案选 3 或 4，值为 3，NaN，3（有的浏览器遇到 0 是报NaN） 例：以下哪些是JavaScript 语言 typeof 可能返回的结果：<br>A.string    B.array    C.object    D.null</p>
<p>原型<br>1.定义：原型是function 对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。 2.利用原型特点和概念，可以提取共有属性。<br>3.对象属性的增删和原型上属性增删改查。<br>4.对象如何查看原型 ==&gt;  隐式属性    proto    。 5.对象如何查看对象的构造函数 ==&gt; constructor。<br>例 person.prototype    //原型（描述一种继承关系），出生时就被定义好了<br>person.prototype ={}    //是祖先</p>
<p>将左上的共有的东西提取出来放在原型里面，如右上图</p>
<p>右上的 person 和 person1 都有一个共有的祖先Person.prototype</p>
<p>上面通过对象（后代）改原型（祖先）是不行的，在对象里面修改，只作用给自己改原型都不行，增加肯定也不行。对象可以删除属性</p>
<p>左上的简化写法见右上    // construnctor 是构造的意思（隐式是浅粉色）</p>
<p>浅粉色是系统帮你设置的，深紫色是自己设置的</p>
<p>自己身上有属性，原型上也有属性，取近的，用自己的</p>
<p>在原型内部自带constructor，指的是Car。通过 constructor 能找的谁构造的自己</p>
<p>例</p>
<p>例</p>
<p>constructor 可以被人工手动更改例</p>
<p>例</p>
<p>浅粉色的    proto    是系统的隐式的属性,前面两个_后面两个_，可以修改，尽量不改。在开发的时候，如果很私人可以写成_private，告诉同事别动。<br>上面的 proto 放的是原型。 proto 存的对象的原型<br>上面的 var this ={  proto   :person.prototype};这个对象并不是空的，这个 proto，当你访问这个对象的属性时，如果对象没有这个属性，那么就会访问 proto 索引，看看有没有。有一个连接的关系，原型和自己连接到一起<br>例</p>
<p>Person 的原型是可以被修改的</p>
<p>Person.prototype.name 这种.的写法是在原有的基础上把值改了。改的是属性，也就是房间里面的东西。<br>而Person.prototype={name:’cherry’}是把原型改了，换了新的对象。改了个房间。上面在 new 的时候 var this = {  proto :Person.prototype}里面的指向Person，此时Person.prototype 与 proto 指向的是一个空间，把他返回给var person。<br>先 new 再Person.prototype={name:’cherry’}已经晚了<br>在Person.prototype={name:’cherry’}时，Person.prototype 空间改了，但是 proto 指向的空间不变。<br>上面的步骤实际上是→<br>例</p>
<p>例</p>
<p>上面这种思考过程：程序执行顺序<br>1.先把 function Person(){}在预编译的过程中提到最上面2.再执行 Person.prototype.name =  ‘sunny’这一样行3.再执行 Person.prototype = {name:’cherry’}<br>4.最后执行 var    person = new Person();执行到 new 的时候，才会发生//var this<br>={ proto :Person.prototype}<br>5.下面的把上面的覆盖了6.答案是 cherry<br>例</p>
<p>这说明原型里面有原型例<br>原型链</p>
<p>执行 son.toString    //返回 function toString( ){ [native code] }，这里返回的是原型链终端的 toString<br>Grand.prototype.   proto     = Object.prototype    // Object.prototype 是原型链的终端</p>
<p> 原型链<br>1、如何构成原型链?（见上一个例子）<br>2、原型链上属性的增删改查<br>原型链上的增删改查和原型基本上是一致的。只有本人有的权限，子孙是没有的。<br>3、谁调用的方法内部this 就是谁-原型案例<br>4、绝大多数对象的最终都会继承自Object.prototype 5、Object.create(原型);<br>6、原型方法上的重写例</p>
<p>son.fortune.card2=’master’这种改，这是引用值自己的修改。属于 fortune.name 给自己修改，这是一种调用方法的修改<br>例</p>
<p>son.num++是 son.num=son.num+1 是先把父级的取过来再赋值+1， 所以爹的没变</p>
<p>例    例 var obj = { };也是有原型的<br>var obj = { };与 var obj1 = new Object( );效果是一样的写 var obj = { }; 系统会在内部来一个 new Object( );</p>
<p>obj1.   proto     </p>
<p>→    Object.ptototype;</p>
<p>但是在构造对象时，能用对象自变量 var obj = { };就不要用 var obj1 = new Object( );<br>例</p>
<p>console.log(this.name);    //如果写成 name 就会错，没有这个变量<br>例</p>
<p>//a.sayName ( )方法调用，就是 say.Name 里面的 this 指向，是谁调用的这个方法，this 就指向谁<br>例</p>
<p>this.height ++;    //这后面默认有一个 return undefined<br>例</p>
<p>对像自变量的原型就是Object.ptototype;<br>Object.create(原型);<br>//var obj = Object.create(原型);<br>Object.create 也能创建对象。var obj = Object.create（这里必须要有原型） 例</p>
<p>例</p>
<p> 绝大多数对象的最终都会继承自 Object.prototype<br>例 html 里面没有添加任何东西这样就报错</p>
<p>原型是隐式的内部属性，你加是没有用的</p>
<p>例    例<br>Object.create()在括号里面只能放null 或者Object，其余会报错<br>例 undefined 和null 没有原型，也就不可能有toString 方法</p>
<p>例下面 123.toString 首先会识别成浮点型，所以在后面直接加.toString 是不行的</p>
<p>数字想用 toString 方法，要经过包装类包装new Number(num)然后. toString<br>例加深上面的理解</p>
<p>而 new Number(num). toString 的原型是Nunber.prototype，而 Nunber.prototype 上面有一个.toString 方法，Nunber.prototype 也有原型Nunber.prototype. proto ，原型是<br>Object.prototype<br>假如 new Number 上面的prototype 上面有这个 toString，那么就不用 Object.prototype<br>的 toString。而这个 number 上面有这个 toString。<br>然后 number 上面的 toString 调用的是自己重写的 toString。<br> 原型上有这个方法，我自己又写了一个和原型上同一名字，但不同功能的方法，叫<br> 做重写（同一名字的函数，不同重写方式） 通过返回值，形参列表不同传参<br>同样的名实现不同功能的，就是重写</p>
<p>和原型链上终端方法名字一样，但实现不同的功能，叫做方法的重写。也就是覆盖</p>
<p>下面这个也是重写</p>
<p>例让 object 上面的 toString 重写了。<br>所以 num.toString()调用的是 number. prototype.toString。</p>
<p>如果调用的是 object. prototype.toString 结果会不一样。</p>
<p>例</p>
<p>例例例<br>document.write 会隐式的调用 toString 方法，其实打印的是 toString 的结果</p>
<p>没有原型就不能 toString<br>例</p>
<p>上面这个例子表示：我要打印的是 obj，实际上打印出来的是 toString 方法，也证明了 document.write 调用的是 toString 方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-4-object/" data-id="ck7xh5r2t000ecku119jsfzib" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-3-closure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-3-closure/" class="article-date">
  <time datetime="2020-03-10T15:14:54.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-3-closure/">js-basics-3-closure</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>闭包（closure）</p>
<p>eg: Person();<br>四、模块化开发，防止污染全局变量<br>立即执行函数</p>
<p>例(function (){    //写成(function abc(){}())也调用不到<br>var a = 123; var b = 234;<br>console.log(a + b);<br>}())<br>例 (function (a, b, c){ console.log(a + b + c * 2);<br>}(1, 2, 3))这一行里面的(1,2,3)是实参例 var num = (function (a, b, c){<br>var d = a + b + c * 2 – 2; return d;<br>}(1, 2, 3))<br>答案 num = 7</p>
<p>}<br>答案这也是函数声明例 function (){<br>var a = 123;<br>}<br>test();<br>答案 test()；就是表达式，所以能执行<br>。    例 var test = function (){<br>console.log(‘a’);<br>}()<br>答案这是表达式，可以被执行，此时在控制台执行 test 的结果是 undefined，这个函数的名字就会被放弃<br>例+ function test(){<br>console.log(‘a’);<br>}()<br>答案加了个“正“，在趋势上要把他转换成数字，就是表达式了，既然是表达式就能被执行，就会放弃名字，此时console.log (test)，就会报错；这就是立即执行函数同样放了正号，负号，！就会放弃函数名字，转换成表达式；但是*和/不行，&amp;&amp;||前面放东西也行<br>例 var test = function (){}<br>其中= function (){}把 function 赋到 test 里面去叫表达式，var test 是声明<br>在执行时，会放弃这个函数，储存到 test 里面储存引用，让这个 test 恢复到被声明的<br>状态</p>
<p>例(function test(){console.log(‘a’);})()<br>这个被()包起来的 function 函数声明变表达式了，就能被外面的最后的()执行例(function test(){console.log(‘a’);} ())<br>最外面的大括号是数学运算符号，是最先被执行，其余的括号都是有语法意义的， 就把函数变表达式了<br>()也是数学执行符，能打印 a，但是执行 test 就报错，所以干脆就不写 test<br>例 function test (a, b, c, d){<br>console.log(a + b + c + d);<br>}(1, 2, 3, 4);    //写成(1)也是这种效果<br>理论上不能执行，只写()就会被当成执行符，但是(1, 2, 3, 4);这样写暂时不会当成运算符，没意义，但是不会执行，也不报错。还能调用 test<br>例先定义一个 10 位数的数组，就是在var arr = [function () {console.log(i);}有十个]并且把数组返回<br>function test (){    //定义个函数 test var arr = [];        //定义一个空数组<br>for (var i = 0; i &lt; 10; i ++){<br>//丰满空数组，让空数组添加十条数组， 每一条都是一个 function(){}<br>arr[i] = function () { //随着 for 循环 i 变， 数组 i 也变，arr 每一次都等于一个全新的函数体<br>document.write(i + “ ”);<br>}<br>}<br>return arr;    //把 arr 返回到外部<br>}<br>var myArr = test();<br>for (var j = 0; j &lt; 10; j ++){ //分别执行十个函数体，函数体里面定义了 document.write myArr<a href>j</a>;<br>}<br>答案 10 10 10 10 10 10 10 10 10 10<br>第二个 for 是为了打印这个数组，麻烦写法myArr<a href>0</a>; myArr<a href>1</a>; 。。。myArr<a href>9</a>; 过程 for (var i = 0; i &lt; 10; i ++){}执行了十次，产生了十个彼此独立的函数。并且把这十个函数放在数组里面去，还把数组返回了，这十个函数和 test 一起产生了一个闭包。<br>既然是闭包，那么访问 test 里面的变量时，实际上访问的是同一套，而 test 产生了<br>arr 和 i 变量（写在 for 循环里面的 i 变量），而这十个函数在外边要访问 i 变量，其实<br>访问的是同一个 i。</p>
<p>什么时候访问的？在test 执行完以后，在下面 for(j)访问的<br>第一个 i=0，转到 9 的时候，i ++变 10 终止 for 循环，结束的时候i=10，结束之后把return arr 返回，arr；<br>这十个函数都是为了打印 i 的，在外部访问 i 的时候i=10，所以打印的是 10<br>arr[i] = function () {<br>document.write( i + “ ”);<br>}<br>理解过程：在这个函数体中，当arr[0] 时，document.write(i)的 i 是不变的，还是 i， 等函数保存到外部之后，等执行的时候，才会去找i 的值。<br>这个赋值语句中，arr[0] =  函数;把一个函数体或者说是一个函数引用赋给数组的当前位，数组的当前位需要马上被索取出来的（数组现在是当前第几位，我们是知道的， 因为这个是执行语句），当 for(var i = 0)时，arr[i]会变成 arr[0]，但是这个 i 跟函数体里面的 d.w(i+“”）里面的 i 是没有关系的，因为函数体 function(){}不是现在执行，不会在意函数里面写的是什么，不是现在执行那么里面的 document.write 不会变成现实的值，不是现在执行就是函数引用（函数引用就是被折叠起来的，系统不知道里 面写的是什么）<br>在执行 myArr<a href>j</a>;的时候，系统才会读 document.write(i +””)里面的语句在定义函数的时候是不看里面的，在执行的时候才看<br>例我们让上面这个变成打印 0,1,2,3,4,5,6,7,8,9，用立即执行函数解决<br>function test (){<br>var arr = [];<br>for (var i = 0; i &lt; 10; i ++){ (function (j) {<br>arr[j] = function () { document.write( j + “ ”);<br>}<br>}(i));<br>return arr;<br>}<br>var myArr = test();<br>for (var j = 0; j &lt; 10; j ++){ myArr<a href>j</a>;<br>}<br>理解过程：相当于在 for 循环里面有十个立即执行函数 function(j){}<br>在第一圈 i 是 0，j 也是 0，function(){document.write( j + “ ”)}拿着 j=0，进行循环的第二圈 i 是 1，又有了一个新的j 是 1，反复循环<br>形成了十个立即执行函数，有十个 j 对应</p>
<p>例 for(var i = 0; i &lt; 10; i ++){ console.log(i);<br>}<br>答案 0,1,2,3,4,5,6,7,8,9<br>例 for(var i = 0; i &lt; 10; i ++){<br>(function(){<br>}())<br>}<br>中间 function 这个会执行 10 次</p>
<p>=“”等号后面的引号里面需要有值才可以    删除必须借助 delete mrDeng.sex</p>
<p>一定要注意——闭包的防范</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-3-closure/" data-id="ck7xh5r3c000gcku195q674us" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-2-precompile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-2-precompile/" class="article-date">
  <time datetime="2020-03-10T15:09:38.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-2-precompile/">js-basics-2-precompile</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js 运行三部曲（主要探讨预编译）</p>
<p>1 语法分析 → 2 预编译 → 3 解释执行<br>预编译前奏<br>例 function test(){ console.log(‘a’);<br>}<br>test();<br>上面能执行例 test();<br>function test(){ console.log(‘a’);<br>}<br>也能执行，因为有预编译的存在例 var a = 123;<br>console.log(a);<br>答案 123<br>例 console.log(a);<br>var a = 123;</p>
<p>答案 undefined<br>例只写 console.log(a);就会报错<br>函数声明整体提升：函数不管写到哪里，都会被提到逻辑的最前面。所以不管在哪里调用，本质上都是在后面调用<br>变量    声明提升：把 var a 提升到最前面<br>var a = 123;这是变量声明再赋值。<br>变量    声明提升是把他拆分成var a; a = 123;然后把 var a 提升到最前面上面这两句话没办法解决下面例子的问题<br>例 function a(a){<br>var a = 234;<br>var a = function(){<br>} a();<br>}<br>var a =123;<br>1.imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象(就是window)所有。<br>全局对象是window<br>例 window.a = 10;<br>例 a = 10; ===&gt; windows.a = 10;<br>eg: var a = b = 123;<br>2.一切声明的全局变量，全是window 的属性。<br>例 var a = 123; ===&gt; window.a = 123;<br>window 就是全局的域<br>如果在全局变量在var a = 123；那么就会返回到 window<br>例 var a = 123<br>console.log(a) ===&gt; window.a<br>例 var a = b = 234;是把 234 的值赋给b，在把b 的值赋给 a<br>例 function test(){<br>var a = b = 123;<br>}<br>test()<br>写 test()代表执行 test，赋值是自右向左的，上面先把 123 赋给 b 的时候，b 未经声明，然后再声明 a，再 b 的值赋给 a，导致b 未经声明，所以b 归 window 所有<br>访问 window.a 是 undefined，访问 window.b 是 123<br>例 function test(){<br>var b = 123;</p>
<p>}<br>test(); console.log(window.b);<br>答案 undefined<br>window 就是全局例 var a = 123;<br>console.log(a);    → console.log(window.a);<br>例 var a = 123;<br>var b = 234; var c = 345; window{<br>a : 123,<br>b : 234,<br>c : 345<br>}<br>如果 var a 对应会有 window.a<br>预编译（解决执行顺序问题）<br>例 function fn(a){<br>console.log(a); var a = 123; console.log(a); function a (){} console.log(a);<br>var b = function (){} console.log(b); function d() {}<br>}<br>fn(1);<br>答案是 function a(){}//123//123//function    (){}<br>这个例子的形参是（a），变量声明也是 a<br>上面的例子按四部曲变化如下:<br>找形参和变量声明，将变量和形参（a）名作为AO 属性名，值为 undefined ，AO{<br>a : undefined, b : undefined,<br>}<br>（把实参值传到形参里）AO{ a : 1,</p>
<p>b : undefined,<br>}<br>function a () {}和 function d () {}都是函数声明，但是var b = function (){}不是。AO{ a : function a () {},<br>b : undefined,<br>d : function d () {}<br>}<br>执行第一行 console.log(a);时，用的是 AO{ a : function a () {},<br>b : undefined,<br>d : function d () {}<br>}<br>执行 var a =123;改变的是AO{ a : 123,<br>b : undefined,<br>d : function d () {}<br>}<br>在 b = function (){}时 AO{ a : 123,<br>b : function () {},<br>d : function d () {}<br>}<br>预编译发生在函数执行的前一刻<br>（函数）预编译的四部曲：<br>1.创建 AO 对象 Activation Object(执行期上下文，作用是理解的作用域，函数产生的执行空间库)<br>2.找形参和变量声明，将变量和形参名作为AO 属性名，值为undefined 相当于 AO{<br>     a : undefined, b : undefined<br>}<br>3.将实参值和形参统一（把实参值传到形参里）<br>4.在函数体里面找函数声明，值赋予函数体<br>（先看自己的AO，再看全局的 GO）<br>例子 function test (a, b){<br>console.log(a);<br>c = 0;</p>
<p>var c; a = 3;<br>b = 2;<br>console.log(b); function b (){};<br>function d (){}; console.log(b);<br>}<br>test(1);<br>答题过程：找形参和变量声明，将变量和形参名作为 AO 属性名，值为 undefined, AO{ a : 1,<br>b : undefined, c : undefined<br>}<br>函数声明 function b(){}和 function d(){}，AO{ a : 1,<br>b : function b(){}, c : undefined,<br>d : function d(){}<br>}<br>执行 console.log(a);答案是 1<br>执行 c = 0;变AO{<br>a : 1,<br>b : function b(){}, c : 0,<br>d : function d(){}<br>}<br>var c 不用管，因为 c 已经在 AO 里面了执行 a = 3;改AO{<br>a : 3,<br>b : function b(){}, c : 0,<br>d : function d(){}<br>}<br>执行 b = 2;改AO{ a : 3,<br>b : 2,</p>
<p>c : 0,<br>d : function d(){}<br>}<br>执行 console.log(b);答案是 2<br>function b () {}和 function d(){}已经提过了，不用管执行 console.log(b);答案是 2<br>例 function test(a , b){<br>console.log(a); console.log(b); var b = 234; console.log(b); a = 123;<br>console.log(a); function a (){} var a;<br>b = 234;<br>var b = function(){} console.log(a); console.log(b);<br>}<br>test(1);</p>
<p>答题过程： 将变量和形参名作为 AO 属性名，AO{ a : undefined,<br>b : undefined<br>}<br>将实参值和形参统一，AO{ a : 1,<br>b : undefined<br>}<br>找函数声明 function a (){}，AO{ a : function a (){},<br>b : undefined<br>}<br>执行 console.log(a);答案是 function a (){}<br>执行 console.log(b);答案是 undefined</p>
<p>执行 var b = 234;变 AO{ a : function a (){},<br>b : 234<br>}<br>执行 console.log(b);答案是 234<br>执行 a = 123;变AO{<br>a : 123,<br>b : 234<br>}<br>执行 console.log(a);答案是 123<br>然后 function a (){};var a ;都可以不看了执行 b = 234，b 值还是 234，不变<br>执行 var b = function (){}，变 AO{<br>a : 123,<br>b : function (){}<br>}<br>执行 console.log(a);答案是 123<br>执行 console.log(b);答案是 function (){}<br>下面开始讲全局的预编译<br>例 console.log(a);<br>var a = 123;<br>答案 undefined<br>例 console.log(a);<br>var a = 123; function a (){}<br>答案是打印 a 是 function a (){}<br>全局的预编译三部曲：<br>1、生成了一个 GO 的对象 Global Object（window 就是 GO）<br>2、找形参和变量声明，将变量和形参名作为GO 属性名，值为 undefined<br>3、在函数体里面找函数声明，值赋予函数体<br>例 console.log(a);<br>var a = 123; function a (){}<br>答案过程，GO{<br>a : undefined<br>}<br>函数声明GO{</p>
<p>a : function a (){}<br>}<br>执行 var a = 123;变 GO{ a : 123<br>}<br>执行 console.log(a);就是 123<br>GO === window， GO 和window 是一个东西<br>console.log(a);和 console.log(window.a);和 console.log(go.a);是一样<br>任何全局变量都是window 上的属性<br>没有声明就是赋值了，归window 所有，就是在 GO 里面预编译<br>例 function test(){<br>var a = b =123; console.log(window.b);<br>}<br>test();<br>答案 a 是 undefined，b 是 123<br>先生成 GO{<br>b : 123<br>}<br>再有AO{<br>a : undefined<br>}<br>先生成 GO 还是AO?<br>想执行全局，先生成 GO，在执行 test 的前一刻生成AO<br>在几层嵌套关系，近的优先，从近的到远的，有 AO 就看AO，AO 没有才看 GO<br>例 console.log(test);<br>function test(test){ console.log(test); var test = 234; console.log(test); function test(){<br>}<br>}<br>test(1);<br>var test = 123;<br>答题过程:想执行全局,先有 GO,GO{ test : undefined</p>
<p>}<br>发现有函数声明 GO{ test : function (){<br>…..<br>}<br>}<br>执 行 console.log(test)， 执行 test(1)之前生成 AO{<br>test : function (){}<br>}<br>执行 var test = 234;变成 234<br>AO 上面有就用 AO 的，没有就看 GO 的例 var global = 100;<br>function fn(){ console.log(global);</p>
<p>答 题 过 程 ，GO{ global : undefined<br>fn : undefined(没用可以不写)<br>}<br>变 GO{<br>global : 100 fn : undefined<br>}<br>执行 fn()之前，AO{ global : undefined<br>}<br>执行结果是 undefined，200<br>例</p>
<p>}<br>fn();<br>答题过程GO{<br>global : undefined, fn : function(){.    }</p>
<p>}<br>执行 var global = 100;变GO{ global : 100,<br>fn : function(){.    }<br>}<br>不看 function fn(){. }里面的东西<br>执行 fn()之前 AO{<br>访问 GO 的 global</p>
<p>答案//undefined    //undefined<br>过程GO{<br>a : undefined<br>test:undefined(没用可以不写)<br>}<br>AO{</p>
<p>//234    //234</p>
<p>}    b : undefined    //不管 if（a）{}，可以提出 var b 的 b<br>例    }<br>执行到 c=234，GO{<br>a : undefined c : 234<br>}<br>执行到 a=10，GO{ a : 10<br>c : 234}</p>
<p>例 function bar(){<br>return foo; foo = 10;<br>function foo(){} var foo = 11;<br>}<br>console.log(bar());<br>答案：function foo(){}<br>如果在第一行 return foo，下面有 foo 这个函数，一定打印这个函数例 console.log(bar());<br>function bar(){ foo = 10; function foo(){} var foo = 11; returm foo;<br>}<br>答案 11<br>例 console.log(b);<br>var b = function (){}<br>答案是 undefined<br>例现在在 if 里面定义函数声明 function 是不允许的，但是过去可以，下面就是过去的旧题，按可以来做</p>
<p>GO{<br>a : undefined<br>}<br>GO{<br>a : undefined<br>demo : function (){}<br>}<br>开始执行 a=100，GO{ a : 100<br>demo : function (){}<br>}<br>AO{<br>e : undefined, b : undefined, c : undefined, a : undefined<br>}<br>形参实参相统一，AO{ e : 1,<br>b : undefined, c : undefined, a : undefined<br>}<br>赋值AO{<br>e : function e (){}, b : undefined,<br>c : undefined,    旧规则里面可以提出 function(){}<br>a : undefined</p>
<p>}<br>执行 arguments[0] = 2;实参列表和传参是否相映射，变 AO{ e : 2,<br>b : undefined, c : undefined, a : undefined<br>}<br>执行 console.log(e);答案 2<br>if(a)由于 a 在 AO 里面是 undefined，所以不走 if</p>
<p>执行 a = 10;变AO{ e : 2,<br>b : undefined, c : undefined, a : 10<br>}<br>执行 console.log(b)，答案 undefined<br>执行 f = 123，变 GO{<br>a : 100,<br>demo : function (){}, f : 123<br>}<br>执行 console.log(c);    之前打印 function(){}，改语法后打印 undefined<br>执行 console.log(a);    答案 10<br>执行 console.log(a);    因为在外面是全局的，答案 100<br>执行 console.log(a);    答案 123<br>例</p>
<p>答题//1    false+1 因为有+，两边都不是字符串，就转换成数字，false 是 0<br>//false    false==1，false 肯定不等于 1，所以把 false 再赋给 demo<br>//undefined<br>typeof(a) 出 现”undefined”    -true 转换成数字是-1    +undefined 显示“NaN”<br>-1 + NaN = NaN<br>-1 + NaN + “” = “NaN”<br>“undefined” &amp;&amp; “NaN”转换成 boolean，就都是true<br>“11”* 2 是<em>把两边转换成了数字，所以 11 +“11”</em> 2 =33，33 == 33，两边相等<br>!!非非就是正<br>“ ”这不是空串，是空格字符串<br>!!” ”转换成 Boolean 为 true<br>!!””非非空串，转换为 Boolean 为 false</p>
<p>!!false 就是 false<br>true + false - false = 1 + 0 – 0 =1<br>11|| document.write(‘你觉得能打印？’)<br>||遇到真就听，1 为真，所以返回 1<br>例(window.foo || (window.foo = ‘bar’));求 window.foo<br>答案”bar”<br>这道题要先看(window.foo = ‘bar’)这一边的，再看左边的 window.foo，因为运算符的顺序；但是这道题错误的读法（从左到右）也是 bar<br>(window.foo || window.foo = ‘bar’);这么写就报错；||或运算符优先级高于=等号<br>作用域精解<br>[[scope]]:每个 javascript 函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供 javascript 引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域,其中存储了运行期上下文的集合。<br> 作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。<br> 运行期上下文:当函数在执行的前一刻，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁。<br> 查找变量：在哪个函数里面查找变量，就从哪个函数作用域链的顶端依次向下查找。函数类对象，我们能访问test.name<br>test.[[scope]]隐式属性——作用域例 function test (){<br>}<br>第一次执行 test();    →    AO{}    //AO 是用完就不要的第二次执行 test();    →    AO{}    //这是另外的 AO<br>例 function a (){<br>function b (){ var bb = 234; aa = 0;<br>}<br>var aa = 123; b();<br>console.log(aa)<br>}<br>var glob = 100; a();</p>
<p>0 是最顶端，1 是次顶端，查找顺序是从最顶端往下查<br>理解过程：bb 的AO 是拿到 aa 的 AO，就是同一个 AO，bb 只是引用了 aa 的 AO， GO 也都是同一个。function b(){}执行完，干掉的是b 自己的 AO（销毁执行期上下文）（去掉连接线），下次 function b 被执行时，产生的是新的b 的 AO。b 执行完只会销毁自己的 AO，不会销毁 a 的 AO。function a(){}执行完，会把 a 自己的 AO 销毁<br>【会把 function b 也销毁】，只剩 GO（回归到 a 被定义的时候），等下次 function a再次被执行时，会产生一个全新的 AO，里面有一个新的 b 函数。。。。。。周而复始例</p>
<p>理解过程<br>a 被定义 a.[[scope]]    →    0 : GO{}<br>a 被执行 a.[[scope]]    →    0 : aAO{}<br>1 : GO{}<br>b 被定义 b.[[scope]]    →    0 : aAO{}<br>1 : GO{}<br>b 被执行 b.[[scope]]    →    0 : bAO{}<br>1 : aAO{}<br>2 : GO{}<br>c 被定义 c.[[scope]]    →    0 : bAO{}<br>1 : aAO{}<br>2 : GO{}<br>c 被执行 c.[[scope]]    →    0 : cAO{}<br>1: bAO{}<br>2: aAO{}<br>3 : GO{}<br>当 c 执行完后，会干掉自己的 cAO，回到c 被定义的状态，当 c 再被执行时，会生成一个新的 newcAO{}，其余都一样，因为基础都是 c 的被定义状态<br>c 被执行 c.[[scope]]    →    0 : newcAO{}<br>1: bAO{}<br>2: aAO{}<br>3 : GO{}<br>如果 function a 不被执行，下面的 function b 和 function c 都是看不到的（也不会被执行，被折叠）。只有 function a 被执行，才能执行function a 里面的内容<br>a();不执行，根本看不到 function a (){}里面的内容</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-2-precompile/" data-id="ck7xh5r2n000bcku10766ao9u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-basics-1-type" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/10/js-basics-1-type/" class="article-date">
  <time datetime="2020-03-10T14:59:23.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/10/js-basics-1-type/">js-basics-1-type</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JavaScript</p>
<p>web 发展史<br>Mosaic，是互联网历史上第一个获普遍使用和能够显示图片的网页浏览器。于 1993<br>年问世。<br>1994 年 4 月，马克.安德森和 Silicon Graphics（简称为 SGI，中译为“视算科技”或“硅图”）公司的创始人吉姆·克拉克（Jim Clark）在美国加州设立了“Mosaic Communication Corporation”。<br>Mosaic 公司成立后，由于伊利诺伊大学拥有 Mosaic 的商标权，且伊利诺伊大学已将技术转让给 Spy Glass 公司，开发团队必须彻底重新撰写浏览器程式码，且浏览器名称更改为Netscape Navigator，公司名字于 1994 年 11 月改名为“Netscape<br>Communication Corporation”，此后沿用至今，中译为“网景”。<br>微软的Internet Explorer及Mozilla Firefox等，其早期版本皆以Mosaic 为基础而开发。微软随后买下Spy Glass 公司的技术开发出Internet Explorer 浏览器，而Mozilla Firefox 则是网景通讯家开放源代码后所衍生出的版本。<br>js 历史<br>JavaScript 作为 Netscape Navigator 浏览器的一部分首次出现在 1996 年。它最初的设计目标是改善网页的用户体验。<br>作者：Brendan Eich<br>期初JavaScript 被命名为 LiveScript，后因和 Sun 公司合作，因市场宣传需要改名<br>JavaScript。后来 Sun 公司被 Oracle 收购，JavaScript 版权归 Oracle 所有。</p>
<p>js 的特有特色</p>
<pre><code>编译型语言    解释性语言</code></pre><p>怎么做    通篇翻译后，生成翻译完的文件，<br>程序执行翻译后的文件    看一行翻译一行，不生成特<br>定文件<br>代表语言    C,C++    JS,PHP，python 带尖角号<br>优点    快(常用于系统，游戏)    可以跨平台<br>缺点    移植性不好（不跨平台，window 和<br>Linux 不能混用）    稍微慢点<br>js 是解释性语言：(不需要编译成文件）跨平台<br>java 先通过 javac，编译成.class 文件，通过 jvm（Java 虚拟机）进行解释执行<br>.java→javac→编译→.class→jvm→解释执行（java 可以跨平台）（java 是 oak 语言）</p>
<link rel="“”">是异步加载
单线程：同一时间只能做一件事——js 引擎是单线程
（同一时间做很多事叫多线程）
ECMA（欧洲计算机制造联合会）标注：为了取得技术优势，微软推出了 JScript， CEnvi 推出ScriptEase，与 JavaScript 同样可在浏览器上运行。为了统一规格 JavaScript兼容于 ECMA 标准，因此也称为ECMAScript。
js 是轮转时间片


<p>浏览器组成<br>1.shell 部分——用户能操作部分(壳)<br>2.内核部分——用户看不到的部分<br>1)渲染引擎（语法规则和渲染） 2)js 引擎<br>3)其他模块（如异步）</p>
<p>js 引擎<br>2001 年发布 ie6，首次实现对 js 引擎的优化。<br>2008 年Google 发布最新浏览器Chrome，它是采用优化后的 javascript 引擎，引擎代号 V8，因能把 js 代码直接转化为机械码来执行，进而以速度快而闻名。<br>后 Firefox 也推出了具备强大功能的 js 引擎<br>Firefox3.5    TraceMonkey（对频繁执行的代码做了路径优化）<br>Firefox4.0    JeagerMonkey</p>
<p>开始学习 js<br>js 三大部分 ECMAScript、DOM、BOM<br>如何引入 js?<br>1、页面内嵌<script></script>标签,写 head 里面也行,写 body 里面也行<br>例<body></body></p>
<script type="text/javascript">    //告诉浏览器我们是 js
</script>

2、外部 js 文件，引入<script src="“location”"></script>
例如：以 lesson.js 保存文件，再引入到html 中
为符合 web 标准（w3c 标准中的一项）结构（html）、行为（js）、样式（css）相分离，通常会采用外部引入。
一个文件中可以包括多个 css，js——不混用特殊写页面，大部分写在外部——不混用
如果同时写了内部的 js 和外部的 js，那么是外部的 js 文件显示出来
js 基本语法
1、变量(variable)
HTML，css 不是编程语言，是计算机语言，编程语言需要有变量和函数变量是存放东西，方便后续使用的框
1）变量声明
1.声明、赋值分解
var a; 这个叫变量声明。我们向系统中申请了 var 这个框，命名叫a

<p>下面是变量,例：var a = 10;<br>var b = 20; var c;<br>c = a + b;</p>
<p>基本语法</p>
<p>给 a 赋值 100，写作a =100，这里不是等号是赋值var a ；a =100；可以简化写成 var a=100；<br>2.单一var 声明法<br>var a,b,c,d;————单一 var 模式</p>
<p>先运算等号右边的a+b，运算完后，再赋值给左边 c<br>先取值，再赋值<br>运算大于赋值的优先级<br>js 是动态语言，动态语言基本上都是解释性语言，解释性语言基本上都是脚本语言<br>js 是浮点型语言（带小数点）</p>
<p>标准写法</p>
<p>如写做：var a = 10；a=20;那么后面的 20 就会覆盖掉前面的 10<br>2）命名规则（用接近的英文单词）———— 起变量名一定要以英文语义化<br>1.变量名必须以英文字母、_、$ 开头<br>2.变量名可以包括英文字母、_、$、数字<br>3.不可以用系统的关键字、保留字作为变量名</p>
<p>1、不可改变的原始值（栈数据）栈 stack Number,String,Boolean,undefined,null<br>已经放进去的值不可改变，只会改房间编号为 null(硬盘原理) Number 数字,例 var a = 123;<br>String 字符串,语言放双引号里，例 var a=”语言”，““是空串 Boolean 布尔数字,就两个值，false，true<br>undefined 是        ，表示还没赋值,仅一个值 underfined null 代表空，    用，用空值来覆盖</p>
<p>例 var a =10; var b = a;<br>a = 20;<br>document.write(b);<br>答案：10<br>原始值是我把一个值放到另一个值里面，改了第一个值，第二个值不变<br>2、引用值（堆数据）大致上放堆heap 里面array 数组, Object, function … data,RegExp 正则var arr = [1,2,3,4,5,false,”abc”];    //这是数组例：var arr = [1];<br>var arr1 = arr; arr.push(2); document.write(arr1);<br>答案：arr 是 1,2。arr1 是 1,2<br>引用值是把第一个值放到第二个值里面，改第一个值，第二个值也改变<br>js 由值决定类型。原始值和引用值唯一的不同是赋值形式不同</p>
<p>js 语句基本规则<br>1、语句后面要用分号结束“；”但function test(){}，for(){}，if(){}后面都不用加分号 2、js 语法错误会引发后续代码终止，但不会影响其它 js 代码块<br>错误分为两种<br>1）低级错误（语法解析错误），不能写中文<br>2）逻辑错误（标准错误，情有可原，错的那个执行不了）<br>3、书写格式要规范，“= + / -”两边都应该有空格<br>js 运算符<br>一、运算操作符<br>+</p>
<p>例 var a =  “a”+ true + 1;    //打印 atrue1<br>例 var a = 1 +  “a”  + 1 + 1;    //打印 1a11<br>例 var a = 1 + 1 +  “a” + 1 + 1;    //打印 2a11，从左向右运算例 var a = 1 + 1 +  “a”  +( 1 + 2);        //打印 2a3</p>
<p>var a = 10;var b =a；是 a 先取出 10，copy 一份放到 b 里面，改变 a 的值，b 的值是不变的，再把 a=20;时 b 的值还是 10，不发生改变<br>var arr = [1,2];var arr1 =arr;arr.push(3);<br>答案：这往[1,2]放 3，arr 和 arr1 都是[1,2,3]<br> 引用值是在栈内存里面放堆的地址，拷贝的也是地址，所以改变 arr，arr1 也变了<br>var arr = [1,2]; var arr1 =arr; arr = [1,3]; document.write(arr1)<br>答案：arr = [1,3];是新建了一个新的房间。arr1 是 1,2,现在是插入新引入值”房间”,<br>会在堆里面重新申请一间房，并指向新房间</p>
<p>例 var a = 0 – 1；    //等于-1<br>例 var a = 2 * 1；    //等于 2<br>例 var a = 0 / 0；    //答案是 NaN，应该得出一个数字类型的数，但是没法表达，就用NaN (NaN 是Not a Number 非数，不是数，但是是数字类型<br>例 var a = 1 / 0;    //是 infinity<br>例 var a = -1 / 0;    /是-infinity<br>%，摩尔，模，是取余数的意思<br>例 var a =5%2    //5%2 是五除二的余数，商二余一<br>例 var a =5%1    //是五除一的余数，结果是 0<br>例 var num = 1 % 5;    //意思是 1 除以 5 的余数。商 0 余 1<br>例 var a =4%6    //是四除六的余数，结果是 4<br>例 var a = 4;a % = 5;document.write(a);    // 4<br>例 var a = 0;a % = 5;document.write(a);    //0<br>例 var a = 10;a %= 2;document.write(a);    //0<br>例 var a = 3;a % = 4;    //4<br>“-”，“*”，“/“，“%”，”=“，“()”<br>优先级”=“最弱【赋值符号优先级最低】，”()”优先级较高</p>
<p> “++”，“- -”，”+=“，“-=”，“/=“，“*=”，“%=”<br>++<br>例 var a = 10;    a = a + 1;    //结果 11<br>例 var a = 1;<br>a = a + 1;写成 a ++是一种简化形式“++”，是自身加一，再赋值给自身 a++是 a=a+1 的简化形式<br>例 var a =10；document.write(++a );document.write(a);    //答案 11；11<br> 是先执行++，再执行本条语句 document.write(++a)<br>例 var  a =1；document.write(a ++);document.write(a);    //答案 1；2。是先执行<br> 语句(document.write(a))，再++，所以第一次打印的还是 a，第二次打印 a++后的值例 var a =10；var b=++a -1+a++;document.write(b +  “  ” + a)    //答案 21    12<br> 先++a，这个时候 a=11，再-1，再加 a，b 就是 21，最后++，a 就是 12<br>赋值的顺序自右向左，计算的顺序自左向右（按数学来）<br>例 var a =1；var b = a ++ + 1；document.write(b)；    //答案 2，先执行 var b =a+1， 再 a++<br>例 var a =1；var b = a ++ + 1；document.write(a)；document.write(b)；        //答案 2，2 例 var a =1；var b = ++a + 1；document.write(a)；document.write(b)；    //答案 2，3 例 var i = 1;var a = i++;    //答案 a = 1;    此时 i 先将值 1 赋给 a,然后自己+1，i=2; var b = ++i;    //答案 b = 3；此时 i 先自己+1 为 3.再给 b 赋值，b=3;<br>–<br>“- -”，是自身减一，在赋值给自身<br>例 var a = 1;var b = a– + – a;document.write(b);    //答案 0， 先执行–a;此时 a 变成 0，然后第一个a 也变成 0，那么 b = 0– + –a<br>例 var a = 1;var b = –a + –a;document.write(b);    //答案-1<br>例 var a = 1;document.write(a++);document.write(a);    //答案 1；2 例 var a = 1;document.write(++a);document.write(a);    //答案 2；2 例 var a =1; var b = a ++ +1;document.write(b);        //答案 2<br>a 写在后面就后运行，先计算 a+1=2 赋值给b 后再++<br>例 var a = 1;var b= ++a + 1;document.write(a);document.write(b);    //答案 2；3</p>
<p>例 var a =10;a ++;a ++;a ++;加十个<br>简化写法：a +=10;也是 a = a+10;<br>例 var a =10;a += 10 + 1;    //答案 21<br>例 var a = 1;a = a + 10;等于a+=10 a++是 a +=1 的写法<br>/=<br>例 var a=10;a/=2;    //答案 5，是除二赋给自身的意思</p>
<p>*=<br>例 var a =10;a *=2;    //答案：20，是乘二赋给自身的意思<br>%=<br>例 var a=10;a%=2;    //答案：0， 10 能整除 2,余数是 0,取余，余数赋给自身。例 var a=3;a%=4;        //答案：3，3 除以 4，余数为 3，余数赋给自身。<br>例 var a=0;a%=4;        //答案：0，0 除以 4，余数为 0，余数赋给自身。例 var a = 1;a% =10;    //答案：1，1 除以 10，余数为 1，余数赋给自身。作业：<br>1、写出打印结果<br>var a =(10 * 3 – 4 / 2 + 1)%2,b=3;b %= a + 3;<br>document.write(a++); document.wtite(“<br>”); document.write(–b);<br>2、var a =123; var b =234;经过计算交换 a，b 的值<br>作业答案<br>1、document.write(a++);是 1（先打出 1 再++）<br>document.write(–b);是 2<br>b % =a + 3,3 的模等于 4，除不开再赋值给 b，b 还是 3<br>2、方法一普通方法：var c = a; a = b; b = c;document.write(a ,b);<br>方法二 a = a + b; b = a – b; a = a –b; document.write(a ,b);<br>二、比较运算符<br>1、“&gt;”，”&lt;”，”==”，“&gt;=”，“&lt;=”，”!=”比较结果为boolean 值<br>但凡是运算符，都是要有运算的用到布尔值，true 或false<br>字符串的比较，比的是ASCII 码（七位二进制 0000000）</p>
<blockquote>
<p>， &lt;<br>例 var a = “a”&gt;”b”;document.write(a);    //答案是 false<br>例 var a = 1 &gt; 2;document.write(a);    //答案是 false<br>例 var a = 1 &lt; 2;document.write(a);    //答案是 true<br>例 var a = “1”&gt;”8”;document.write(a);    //答案是 false<br>例 var a = “10”&gt;”8”;document.write(a);    //答案 false，不是十和八比，是字符串一零和八比，先用开头的一和八比，比不过就不看第二位了；一样的就拿零和八比<br>例 var a = 123;document.write(a);    //答案 false<br>运算结果为真实的值<br>= =，等不等于<br>例 var a = 1 == 2;    //答案是说 1 等不等于 2，因为 1 肯定不等于 2，所以值为 false<br>例 var a = NaN == NaN;    //答案是 false，NaN 不等于任何东西，包括他自己</p>
</blockquote>
<p>例 var a = undefined == underfined;    //答案是 true<br>例 var a = infinity == infinity;    //答案是 true<br>例 var a = NaN == NaN;    //答案是 false。非数 NaN 是不等于自己的<br>NaN 得不出数，又是数字类型，就是 NaN</p>
<blockquote>
<p>=，&lt;=<br>!=是否不等于，非等比较结果为 boolean 值：true 和false<br>三、逻辑运算符：“&amp;&amp;”，“||”，“!“运算结果为真实的值<br>  “&amp;&amp;”与运算符</p>
</blockquote>
<p>3 在二进制中，是 11    1    1<br>运算结果            0    1<br>“||”或运算符<br>例 var num = 1 || 3;    //答案 1<br>例 var num = 0 || 3;    //答案 3<br>例 var num = 0 || false;    //答案是 false<br>看第一个表达式是否为真，如果为真，则返回第一个值，碰到真就返回<br>如果第一个表达式是假，就看第二个表达式，如果第二个是最后一个，就返回第二个的值<br>关注真假的说法：全假才为假，有一个真就为真</p>
<p>两个表达式：先看第一个表达式转换成布尔值的结果是否为真，如果结果为真，那么它会看第二个表达式转换为布尔值的结果，然后如果只有两个表达式的话，只看看第二个表达式，就可以返回该表达式的值了，如果第一位布尔值为 false，不看后面的，返回第一个表达式的值就可以了<br>运算符就是要求结果<br>例 var a = 1 &amp;&amp; 2;    //答案 2，如果第一位 1 为真，结果就为第二位的值 2<br>例 var a = 1 &amp;&amp; 2 + 2;    //答案 4，如果 1 为真，结果就为 4<br>例 var a = 0 &amp;&amp; 2 + 2;    //答案 0<br>例 var a = 1 &amp;&amp; 1 &amp;&amp; 8;    //答案 8，先看第一个是否为真，为真再看第二个， 中途如果遇到 false，那就返回 false 的值<br>例 var a =1 + 1 &amp;&amp; 1 – 1;document.write(a);    //答案 0<br>如果是三个或多个表达式，会先看第一个表达式是否为真，如果为真，就看第二个表达式，如果第二个也为真，就看第三个表达式（如果为真就往后看，一旦遇到假就返回到假的值），如果第三个是最后一个表达式，那就直接返回第三个的结果<br>如果第一个是假，就返回第一个值，当是真的时候就往后走，一旦遇到假，就返回例：2&gt;1 &amp;&amp; document.write(‘成哥很帅’)    //意思是如果 2 大于 1，那么就打印成哥很帅，如果前面真才能执行后面的（相当于短路语句使用）<br>&amp;&amp;与运算符是有中断作用的，当短路语句使用(如果。。那么。。)<br>例 var data = …;    //执行一个语句，会用到 data data&amp;&amp;执行一个语句全用到 data<br>例 data &amp;&amp; function(data);<br>&amp;与运算    我们一般不用<br>例 var num = 1 &amp; 2;document.write(num);    //答案 0<br>例 var num = 1 &amp; 1;document.write(num);    //答案 1<br>例 var num = 1 &amp; 3;document.write(num);    //答案 1</p>
<p>例 var num = 0 || false || 1;document.write(num);    //答案 1<br>例 div .onclick = function(e){<br>非 IE 浏览器直接取e 值<br>var event = e;<br>IE 浏览器存在 window.event;<br>}<br>写成下面这样就解决了兼容性。在所有的浏览器中都好使<br>div .onclick = function(e){var event = e || window.event;}<br>“!“非运算符，否的意思。<br>先转成布尔值，再取反<br>例 var a = ! 123;document.write(a);  //答案 false。123 的布尔值是 true，取反是 false 例 var a = ! “”;document.write(a);  //答案 true。空串””布尔值是 false，取反是 true 例 var a = ! !“”;document.write(a);    //答案 false，取反后，再反过来，结果不变例 var a = true;a =!a;document.write(a) //答案 false，自身取反，再赋值给自身<br>！=非等于是表达他们到底等不等的<br>四、被认定为false 的值：转换为布尔值会被认定为false 的值undefined，null，NaN， “”（空串），  0，  false<br>条件语句<br>if(条件判断){<br>当条件成立时，执行里面的执行语句<br>}<br>当 if 的条件成立时，才能执行{}内的语句<br>当条件转化为布尔值，如果为true 就执行；如果为false 就不执行例 if(1 &lt; 2){document.write(“老邓很丑”);}<br>例 if ( 1 &gt; 0 &amp;&amp; 8 &gt; 9){}<br>&amp;&amp;放在 if 中的，全真才为真，&amp;&amp;是并且的意思</p>
<p>例 if ( 1 &gt; 0 || 8 &gt; 9){}<br>||放在 if 中是或者的意思，有一个是真就可以了</p>
<p>IF 和&amp;&amp;的互相转化<br>if (1 &gt; 2) {<br>document.write.(‘a’);</p>
<p>}<br>上面与右边效果完全一样 1 &gt; 2 &amp;&amp; document.write(‘a’);<br>&amp;&amp;和 II 比较常用在条件判断中</p>
<p> 格式 for (var i = 0; i &lt; 10; i++) {<br>     }</p>
<p>for 是关键字，（）括号里面三个语句用两个分号隔开，{}里面是循环体打印十个 a，写成：</p>
<p>执行顺序如下：<br>(1)var i= 0;<br>(2)if(i &lt;10){<br>document.write(‘a’)</p>
<p>//不能写 90&lt;score&lt;100,这样写会先比 90&lt;score,等于true 以后再跟 100 比<br>//else if 满足了第一条就不看第二条了，用 else if 要满足条件与条件之间互斥，不能有交叉点。除了上面所有以外的。else if 除了这个以外，满足第一个就不看了，不满<br> 足就看后面的<br>else if 除了这以外在看这个满不满足。满足条件后就不看了下面的写法不够简洁<br>else 是上面这个条件的补集</p>
<p>简洁写法见右边</p>
<p>}<br>把条件判断放到 if 里面,条件判断成立，就执行{}中间的执行体<br>(3)i++<br>看 i++，此时 i 变成 1，i=1； (4)if(i &lt;10){<br>document.write(‘a’)<br>}<br>把条件判断放到 if 里面,条件判断成立，就执行{}中间的执行体<br>(5)i++<br>看 i++，此时 i 变成 1，i=1；<br>——————如此反复<br>先执行一遍(1)，<br>判断(2)执行语句成不成立，条件成立就执行(3),判断(2)执行语句成不成立，条件成立就执行(3),<br>……当有一次判断不成立，就停止</p>
<p>因为看的是执行顺序，写外面也可以，执行顺序是一样，打印十个 a，也可以写成：</p>
<p>打印十个 a，也可以写成：</p>
<p>例 for 循环中的三句只能写一句，打印 100 个数：</p>
<p>例 for 循环中的函数体里面只能写一句，打印 100 个数：</p>
<p>三、while, do while<br>while 循环</p>
<p>例打印 0-9</p>
<p>求 0-9 的和：</p>
<p>例打印 100 以内能被 3 整除，或者能被 5 整除，或者能被 7 整除的数：</p>
<p>用 for 循环打印一百个数：</p>
<p>while 循环是 for 循环的简化版 for(  ； ； ){}，while 循环底层机制是for 循环。for ( ; 只在这一部分写，前后不写 ; ){}</p>
<p>上下这两个完全相等</p>
<p>死循环 never-ending loop 无限循环</p>
<p>例打印一百以内，7 的倍数就输出</p>
<p>例打印一百以内，7 的倍数或逢 7 就输出</p>
<p>do while 循环<br>do while 是不管满不满足条件都会先执行一次，再判断成不成立，如果成立才会执行<br> 第二次，不成立就停止    一般没人用<br>do{</p>
<p>2.</p>
<ol start="3">
<li>第六位是四次运算，第七位是五次运算（第三位=第一位+第二位）<br>第一次计算的完整过程是把第一位和第二位相加，等于第三位，并且把游标向后挪一位。下面 for（里面的 i 是控制循环圈数的）</li>
</ol>
<p>document.write(‘a’); i ++;<br>}while(i &lt; 10)</p>
<p>作业：（先找规律，再写出来）<br>提示：var n = parseInt(window.prompt(‘input’)); JS 可以进行浮点计算<br>1.计算 2 的n 次幂，n 可输入，n 为自然数。<br>2.计算n 的阶乘，n 可输入。即 5！=5<em>4</em>3<em>2</em>1，最好写个 if<br>3.著名的斐波那契额数列(这个数列从第 3 项开始，每一项都等于前两项之和)<br>1 1 2 3 5 8 输出第 n 项<br>4.编写一程序，输入一个三位数的正整数，输出时反向输出。如：输入 456,输出 654<br>5.输入 a,b,c 三个数字，打印出最大的。<br>6.打印出 100 以内的质数（从 1 除到他本身，只能有两个因数）<br>作业答案:<br>1.原有结果*2,mul 是存上一个数的结果</p>
<ol start="4">
<li><p>取模除减。先把 456 提出出来，再反过来。6 是取模除减%10 余 6。再用 456 减 6， 剩下 450；450%100 是 50，50 除以 10，取出 5，450-50 剩下 400；400%100，再反着乘一遍，十位乘以 10，百位乘以 100。（中间的位数其实可以不动）</p>
</li>
<li></li>
<li><p>(1)有一个判断质数的算法(2)看看每一个 i 是不是质数<br>(3)从自身开始除一直除到 1，只能被自己和 1 整除，只能整除 2 次</p>
</li>
</ol>
<p>以下是最简单的方法：从 1 到 10 能整除，除平方数以下的</p>
<p>用 console.log(a);在控制台输出，看看a 被定义了没有<br>条件语句补充</p>
<p>switch 找到满足要求的语句后，后面的语句虽然不判断了，但是也会执行出来<br>加个 break，就可以终止 swich case 语句<br>例</p>
<p>例 if( score == 90){}else if ( score == 100){}<br>例</p>
<p>一、switch case 条件判断语句<br>if(条件判断) switch(条件){<br>case 写条件：里面判是否相符：<br> 如果相符合就执行 case 后面的语句比如 console.log(‘a’)<br>}<br>switch 不负责任，如果判断了 a 是符合条件的，也会把后面的连带打印出来<br>加个 break，就可以终止语句</p>
<p>简化写法</p>
<p>例当 i 是 7 的倍数，或尾数是 7 的时候，不打印<br>for ( var i = 0; i &lt; 100; i++){<br>if( i % 7 == 0 || i % 10 == 7){<br>}else{ console.log(i);<br>}<br>}<br>下面写法更好</p>
<p>continue 终止本次循环，来进行下一次循环</p>
<p>例</p>
<p>break 终止的是 while，对 if 没有影响例从 0 开始加，加到 100 以上就停止</p>
<p>三、continue 继续<br>终止本次循环，后面的都不执行了，来进行下一次的循环<br>// js 里面是没有 goto 的，c 语言里面有</p>
<p>例 var arr = [1,2,3,4,5,6,7,”abc”,undefined];<br>arr [0]  代表查数组的第一位，因为数字是从 0 开始的算的<br>arr [0] = 3;  是指把数组的第一位改成 3，显示 3,2,3,4,5,6,7, ”abc”,undefined arr.length;是数组的长度，有多少位就有多少<br>console.log(arr.length);    //答案是 8 位<br>例：利用 for 循环把数组中的每一位都拿出来——遍历</p>
<p>例：把数组中的每一位都改成 1</p>
<p>例：把数组中的每一位都加 1</p>
<p>二、对象 object<br>面向对象的编程方法<br>var obj = {<br> 里面存属性和方法<br>key 属性名：value 属性值;<br>}<br>在{}面用。属性与属性之间用逗号隔开<br>//属性值可以双引号或单引号；属性名是为了方便找到他，只是一个辅助<br>例</p>
<p>console.log(deng.lastName);    //取值方式 deng.lastName<br>赋 值 deng.lastName = “old deng”;<br>console.log(deng.lastName);<br>编程形式的区别<br>1.面向过程，如c<br>第一步干嘛，第二步干嘛<br>2.面向对象（对象 object）<br>现在 js 是一半面向过程，一半面向对象，前面学的都是面向过程</p>
<p>typeof 能返回的六种数据类型（区分数字类型）<br>number、string、boolean、undefined、object、function<br>例 var num = 123;console.log(typeof(num));    //返回 number<br>写成 console.log(typeof    num );也可以不过最好加括号<br>例 var num = {}; console.log(typeof(num));    //泛泛的引入值都返回 object 例 var num = [];console.log(typeof(num));    //泛泛的引入值都返回 object 例 var num = null;console.log(typeof(num));        //答案 null 返回 object，最早是代替空对象的<br>例 var num = undefined;console.log(typeof(num));    //答案返回 undefined<br>例 var num = fuction(){};console.log(typeof(num));    //  答案返回 function</p>
<p>类型转换<br>例 var num = 1 +“1”;    //显示 11<br>例 var num = 1 *“1”;console.log(typeof(num) +  “:” + num);    //显示 number:1<br>例 var num = 1 -“1”;console.log(typeof(num) +  “:” + num);    //显示 number:0<br>例 var num = “2” -“1”;console.log(typeof(num) + “:” + num); // 显 示 number:1 例 var num = “2” *“1”;console.log(typeof(num) + “:” + num); // 显 示 number:2 以上例子说明 js 有类型转换<br>一、显示类型转换<br>Number(mix) 是想把里面的东西转换成数字<br>例 var num = Number(‘123’); console.log(typeof(num) + “:” + num);<br>答案显示 Number:123，把字符串类型的 123 转换成了 number 类型例 var demo = “123”;<br>var num = Number(demo); console.log(typeof(num) + “:” + num);<br>答案显示 Number:123，上面那一行的 Number 是为了把()里面转换成数字类型<br>例 var demo = true;<br>var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:1<br>例 var demo = false;<br>var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:0<br>例 var demo = null;<br>var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:0<br>例 var demo = undefined;<br>var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:NaN<br>例 var demo = “abc”;<br>var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:NaN<br>例 var demo = “-123”;</p>
<p>var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:-123<br>例 var demo = “123abc”;<br>var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:NaN<br>parseInt(string,radix)<br>parse 是转化，Int 是整型，整数，目的是把里面转换成整数<br>例 var demo =”123”;<br>var num = parseInt(demo); console.log(typeof(num) + “:” + num); 答案显示 number:123<br>例 var demo = true;<br>var num = parseInt(demo); console.log(typeof(num) + “:” + num); 答案显示 number: NaN<br>例 var demo = false;<br>var num = parseInt(demo); console.log(typeof(num) + “:” + num); 答案显示 number: NaN<br>例 var demo = 123.9;<br>var num = parseInt(demo); console.log(typeof(num) + “:” + num);<br>答案显示 number: 123，此处是直接去掉小数，不是四舍五入<br>例 var demo = “10”;<br>var num = parseInt(demo ,16); console.log(typeof(num) + “:” + num); 答案显示 number: 16<br>var num = parseInt(demo ,radix);    //radix 是基底的意思<br>radix 写成 16，系统会认为是以 16 进制为基底， 10（一零）是 16 进制的一零，是以 16 进制为基底，把他转成为 10 进制的数字（就是 16），上面是以目标进制为基底，转换成十进制（radix 范围是 2-36）<br>例 var demo = “3”;<br>var num = parseInt(demo ,2); console.log(typeof(num) + “:” + num);<br>答案显示 number: NaN</p>
<p>例 var demo = “b”;<br>var num = parseInt(demo ,16); console.log(typeof(num) + “:” + num); 答案显示 number: 11<br>例 var demo = “123abc”;<br>var num = parseInt(demo); console.log(typeof(num) + “:” + num); 答案显示 number: 123<br>例 var demo = “100px”;<br>var num = parseInt(demo); console.log(typeof(num) + “:” + num); 答案显示 number: 100<br>parseInt 从数字类开始看，看到非数字类为止，返回原来的数<br>parseFloat(string) parseFloat(string)转换成浮点数字，就是正常小数例 var demo = “100.2”;<br>var num = parseFloat (demo); console.log(typeof(num) + “:” + num); 答案显示 number: 100.2<br>例 var demo = “100.2.3”;<br>var num = parseFloat (demo); console.log(typeof(num) + “:” + num); 答案显示 number: 100.2<br>例 var demo = “100.2abc”;<br>var num = parseFloat (demo); console.log(typeof(num) + “:” + num); 答案显示 number: 100.2<br>parseFloat 从数字类开始看，看到除了第一个点以外的非数字类为截止，返回前面的数<br>toString<br>例 var demo = 123;<br>var num = demo.toString(); console.log(typeof(num) + “:” + num);<br>答案显示 string: 123。相当于把 123 转换字符串。<br>想把谁转换成字符串，就写成谁.toString，上面是想把 demo 转换成 toString，写成<br>demo.toString</p>
<p>例 var demo = undefined; var num = demo.toString();<br>console.log(typeof(num) + “:” + num);<br>答案显示报错，undefined 和 null 不能用 toString</p>
<p>Boolean()转换成布尔值false 和 true<br>例 var demo = “”;<br>var num = String (demo);</p>
<p>Boolean()</p>
<p>例 var demo = 123;<br>var num = demo.toString(8); console.log(typeof(num) + “:” + num); 答案 173，把 123 转成为八进制<br>这里的 radix 意思是以十进制为基底，转换成目标进制（即 8 进制）<br>例 var demo = 10;<br>var num = demo.toString(8); console.log(typeof(num) + “:” + num); 答案 12<br>例 var demo = 20;<br>var num = demo.toString(8); console.log(typeof(num) + “:” + num);<br>答案 24。以十进制为基底，把 20 转换成 8 进制，就是 24<br>例给你一个二进制的数，转换成十六进制，是先从二进制到十进制再到十六进制</p>
<p>console.log(typeof(num) + “:” + num);<br>答案显示 boolean: false</p>
<p>二、隐式类型转换隐式类型转换是跟你转换了也不知道<br>隐式类型转换内部隐式调用的是显示的方法</p>
<p>isNaN ();<br>isNaN ();当你把一个数放到()里，它能判断是不是NaN，先比括号里面的放到 number<br> 里面转换，然后返回来<br>例 console.log(isNaN(NaN);    //答案 true<br>例 console.log(isNaN(“123”);    //答案 false</p>
<p>var num = 10101010;</p>
<p>例 console.log(isNaN“(</p>
<p>abc”);    //答案 true。会调用 number，先把“abc”</p>
<p>var test = parseInt(num, 2); console.log(test.toString(16));<br>答案 aa<br>例 var num = 10000;<br>var test = parseInt(num, 2); console.log(test.toString(16));<br>答案 10</p>
<p>String(mix)</p>
<p>放 number 里面转换，通过number 的转换再和NaN 比对，如果相等就是 true<br>例 console.log(isNaN(null);    //答案 false，在 number 里面放 null 是 0，不是 NaN<br>例 console.log(isNaN(undefined);    //答案 true<br>++/–（加加减减）    +/-（一元正负）<br>例 var a = “123”;<br>a ++;<br>答案 124，++这个符号放到这里，还没运算之前，先把前面的 a 转换成number 的 123<br>例 var a = “abc”;</p>
<p>String(mix)转换成字符串，写什么都成了字符串<br>例 var demo = 123.234;<br>var num = String (demo); console.log(typeof(num) + “:” + num); 答案显示 string: 123.234<br>例 var demo = undefined;<br>var num = String (demo);<br>console.log(typeof(num) + “:” + num);<br>答案显示 string: undefined</p>
<p>a ++;<br>答案 NaN<br>+/-（一元正负）<br>+a;-a;正 a 和负 a 都会变换成数字例 var a =+”abc”;<br>console.log(a + “:” + typeof(a));<br>答案 NaN:number。尽管转换不成数字，也会转换成数字类型，因为里面隐式的调用<br>了一个 number</p>
<p>+</p>
<p> 变成字符串<br>例 var a = “a” +1<br>console.log(a + “:” + typeof(a));</p>
<p><em>和%    乘和模都会转换成 number.<br>例 var a = “1” *1;    console.log(a + “:” + typeof(a));<br>答案 1：number<br>例 var a = “a” *1;    console.log(a + “:” + typeof(a));<br>答案 1：number，先是 number(“a”)的结果乘以 number(1)的结果，最后是 NaN</em>1， 还是NaN，但是数据类型是 number</p>
<p>与或非，都是有类型转换的，不过是返回的是表达式的值，不是隐士类型转换的值， 但是判断是一个类型转换的值</p>
<p>例 var a =1 &gt;  “2”;    console.log(a + “:” + typeof(a));<br>答案 false:boolean，有数字相比较的，就会隐士类型转换成数字类型例 var a =”3” &gt; “2”;    console.log(a + “:” + typeof(a));<br>答案这个没类型转换，这个比的是ASCⅡ<br>例 var a =”3” &gt; 2;    console.log(a + “:” + typeof(a));<br>答案 true：boolean 会转换成数字，因为数字优先</p>
<p>例 var a = 1 ==  “1”;    console.log(a + “:” + typeof(a));<br>答案 true:boolean，也有隐士类型转换<br>例 var a = 1 == true;    console.log(a + “:” + typeof(a));<br>答案相等<br> ！=也是这样<br>特殊东西，在控制台操作<br>例 false&gt;true    //答案 false，会先转换成数字，0&gt;1 当然是错的例 2&gt;1&gt;3        //答案 false<br>例 2&gt;3&lt;1    //答案 true<br>例 10&gt;100&gt;0    //答案 false<br>例 100&gt;10&gt;0    //答案 true<br>以上都是挨个算的，先看前面的是 true 还是 false，再和后面的比，不是顺着下来<br>例 undefined&gt;0    //答案 false<br>例 undefined==0    //答案 false</p>
<p>例 undefined&lt;0    //答案 false<br>例 null&gt;0    //答案 false<br>例 null==0    //答案 false<br>例 null&lt;0    //答案 false<br>例 undefined == null    //答案 true<br>例 NaN ==NaN    //答案 false，NaN 是唯一一个连自己都不等于的<br>三、不发生类型转换<br>===绝对等于（三个等号）    !==绝对不等于<br>例 1 === 1    //答案 true<br>例 1 ===  “1”    //答案 false<br>例 1 !== “1”    //答案 true<br>例 1 !== 1    //答案 false<br>例 NaN =NaN    //答案 false 特殊的<br>例 console.log(a);    //如果定量没定义就直接访问，就 a is not defined 报错； 有一种特殊情况，当且仅当把未定义的变量放到 console.log(typeof(a));里面就访问， 不报错，返回 undefined<br>例 console.log(typeof(a));    //答案 undefined，这个 undefined 是字符串例 console.log(typeof(typeof(a)));        //答案 string。console.log(typeof(typeof(a))); 可以先解析成 console.log(typeof(“undefined”));再返回一次就是 string 字符串<br>上面考的是 typeof(a)返回的六种类型的值（number、string、boolean、undefined、<br>object、function）都是 undefined 字符串作业<br>例 alert(typeof(a));    //返回 string<br>例 alert(typeof(undefined));    //返回 string，undefined<br>例 alert(typeof(NaN));    //返回 number<br>例 alert(typeof(null));    //返回 object<br>例 var a = “123abc”;    //返回 string<br>例 alert(typeof(+a));    //返回 number，NaN<br>例 alert(typeof(!!a));    //返回 boolean<br>例 alert(typeof(a +  “”));    //返回 string<br>例 alert(1 ==  “1”);    //显示 true<br>例 alert(NaN == NaN);    //显示 false<br>例 alert(NaN == undefined);    //显示 false<br>例 alert(  “11” + 11);    //显示 1111<br>例 alert( 1 === “1”);    //显示 false<br>例 alert(parseInt(“123abc”));    //显示 123【parseInt 是截断数字】</p>
<p>例 typeof(typeof(a));    //返回 string<br>例 var num = 123123.345789;alert(num.toFixed(3));<br>答案 123123.346【toFixed(3)是保留三位小数的意思，四舍五入】提示：<br>alert(‘a’);就是弹出框，相当于 console.log</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/js-basics-1-type/" data-id="ck7xh5r3l000icku1aawn47xt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-firstblog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/07/firstblog/" class="article-date">
  <time datetime="2020-03-06T16:37:29.000Z" itemprop="datePublished">2020-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/07/firstblog/">firstblog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Welcome-to-Hexo"><a href="#Welcome-to-Hexo" class="headerlink" title="Welcome to Hexo"></a>Welcome to Hexo</h1><h2 id="Welcome-to-the-world-of-arancat-❤"><a href="#Welcome-to-the-world-of-arancat-❤" class="headerlink" title="Welcome to the world of arancat!❤"></a>Welcome to the world of arancat!❤</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/07/firstblog/" data-id="ck7xh5r1z0003cku1hl2zfjkm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/07/hello-world/" class="article-date">
  <time datetime="2020-03-06T16:05:16.205Z" itemprop="datePublished">2020-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/07/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/07/hello-world/" data-id="ck7xh5r210005cku14roo6qgg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/blog/">&amp;laquo; Prev</a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2020/03/15/RegExp/">RegExp</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/15/js-time/">js-time</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/15/DOM/">DOM</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/11/js-bascis-MindMater/">js-bascis-MindMater</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/11/html-css-basics-sunmmary/">html-css-basics-sunmmary</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>